# 6 JVM指令集

一个JVM指令包含了一个操作码，它声明了要干的事儿，然后跟着零或多个操作数，给出要操作的东西。本章就是要详细介绍每条JVM指令以及它们要干的事儿。

## 6.1 假设：“Must”的含义

每条指令的讲述上下文总是基于已经满足§4（Class文件格式）中讲的静态和结构化约束的JVM代码。讲每一条指令的时候，我们会经常说某种场景“必须”或“必须不”可以：“*value2*的类型必须是`int`。”§4（Class文件格式）中讲的约束保证了所有这种期望实际上都会满足。如果某个指令描述中的某个约束（“必须”或“必须不”）在运行时没有满足，此时JVM的行为则是未定义的。

JVM在链接时使用`class`文件校验器（§4.10）来检查JVM代码是否满足静态和结构化约束。因此，JVM只会尝试执行有效的`class`文件中的代码。在链接时执行校验很有吸引力，因为只需要检查一次，大量减少了运行时要干的活儿。其它的实现策略也是可以的，值要符合*Java语言规范，JavaSE17版*以及*JVM规范，JavaSE17版*。

## 6.2 保留的操作码

除了本章中后面要讲的用在`class`文件（§4（class文件格式））中的指令操作码，还有三个操作码保留给JVM实现内部使用。如果JVM指令集以后要扩展。这些保留的操作码可以确保不会被用到。

其中两个保留的操作码，第254（0xfe）和255（0xff）号，助记符分别为*impdep1*和*impdep2*。这些指令分别为软硬件实现特定功能提供“后门”或陷阱。第三个保留的操作码，第202（0xca）号，助记符为*breakpoint*，用来实现调试器的断点。

尽管这些操作码保留了，但是只能用于JVM内部实现。不能出现在有效的`class`文件中。类似调试器或JIT代码生成器（§2.13）之类的工具可以直接跟已加载的JVM代码进行交互，执行的时候可能会碰见这些操作码。这些工具再面对这些保留指令的时候应当具备一定的矜持。

## 6.3 虚拟机错误

出现异常或由于资源限制而无法实现本章描述的语义时，JVM会抛出一个`VirtualMachineError`或其子类的一个实例。本规范无法预测哪里会出现内部错误或资源限制，而且也不会明确要求应该什么时候把这些事儿报出来。因此，下面定义的任意`VirtualMachineError`子类可以在JVM执行时的任意时间抛出来：

- `InternalError`：内部错误可能是由于虚拟机软件实现导致，也可能是底层宿主系统软件、硬件错误导致。这种错误发现后会异步报出（§2.10），会出现在程序的任意一点上。
- `OutOfMemoryError`：JVM用尽虚拟内存或物理内存，自动存储管理器无法回收足够的内存来满足对象创建请求。
- `StackOverflowError`：JVM用尽了一个线程的栈空间，一般是由于线程执行了一个无界递归导致程序报错。
- `UnknownError`：发生了异常或错误，但是JVM报不出真实的异常或错误。