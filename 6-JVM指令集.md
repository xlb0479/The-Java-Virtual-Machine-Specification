# 6 JVM指令集

一个JVM指令包含了一个操作码，它声明了要干的事儿，然后跟着零或多个操作数，给出要操作的东西。本章就是要详细介绍每条JVM指令以及它们要干的事儿。

## 6.1 假设：“Must”的含义

每条指令的讲述上下文总是基于已经满足§4（Class文件格式）中讲的静态和结构化约束的JVM代码。讲每一条指令的时候，我们会经常说某种场景“必须”或“必须不”可以：“*value2*的类型必须是`int`。”§4（Class文件格式）中讲的约束保证了所有这种期望实际上都会满足。如果某个指令描述中的某个约束（“必须”或“必须不”）在运行时没有满足，此时JVM的行为则是未定义的。

JVM在链接时使用`class`文件校验器（§4.10）来检查JVM代码是否满足静态和结构化约束。因此，JVM只会尝试执行有效的`class`文件中的代码。在链接时执行校验很有吸引力，因为只需要检查一次，大量减少了运行时要干的活儿。其它的实现策略也是可以的，值要符合*Java语言规范，JavaSE17版*以及*JVM规范，JavaSE17版*。

## 6.2 保留的操作码

除了本章中后面要讲的用在`class`文件（§4（class文件格式））中的指令操作码，还有三个操作码保留给JVM实现内部使用。如果JVM指令集以后要扩展。这些保留的操作码可以确保不会被用到。

其中两个保留的操作码，第254（0xfe）和255（0xff）号，助记符分别为*impdep1*和*impdep2*。这些指令分别为软硬件实现特定功能提供“后门”或陷阱。第三个保留的操作码，第202（0xca）号，助记符为*breakpoint*，用来实现调试器的断点。

