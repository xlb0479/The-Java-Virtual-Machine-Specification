# 2 JVM结构

本章要定义的是抽象的东西。这里并不介绍JVM的某种特定实现。

要想正确实现JVM，你要做的就是能读懂`class`文件格式，并且能正确的执行它里面要求你干的事儿。JVM规范并不约束其实现细节，这样会限制大家的想象力。比如运行时数据区的内存结构，垃圾回收算法，以及JVM指令的内部优化（比如如何将其翻译成机器代码），这些事儿都分离到具体实现中去了。

本书中使用的Unicode都遵照了*Unicode标准，第13版*，想了解的可以去看`https://www.unicode.org/`。

## 2.1 class文件结构

编译后拿给JVM执行的代码采用了与硬件和操作系统无关的二进制格式，一般（但不是必须）保存再文件中，也就是`class`文件格式。`class`文件格式精确的定义了类或接口的展现形式，包括内部细节，比如特定平台上对象文件格式需要确定它的某种字节序。

第4章“class文件格式”会详细介绍`class`文件格式。

## 2.2 数据类型

和Java语言类似，JVM也会操作两种类型：*基本类型*和*引用类型*。也就是说，变量中保存的，参数所传递的，方法所返回的，以及你可以操作的也就是这两种值：*基本类型值*和*引用类型值*。

JVM希望几乎所有的类型检查都能再运行时之前完成，通常是让编译器完成，而不是让JVM来干。基本类型的值不需要被标记或者具备可探测性才能在运行时判断出它们的类型，也不需要从引用类型的值中区别出来。因为JVM指令集会使用类型特定的指令来区分出它们所操作的操作数的类型。比如`iadd`，`ladd`，`fadd`，`dadd`都属于JVM指令，都是操作两个数字值，并产生一个数字结果，但每一个都有其特定的操作数类型，分别是：`int`，`long`，`float`，`double`。关于JVM指令集中支持的类型可以看§2.11.1。

JVM包含了关于对象的明确支持。一个对象要么是一个动态分配的类实例，要么是一个数组。对象的引用对应JVM中的`reference`类型。`reference`类型的值则被认为是对象的指针。一个对象可以有多个引用。对象的操作、传递和测试总是要基于`reference`类型的值。

## 2.3 基本类型

JVM支持的基本数据类型包括*数字类型*，`boolean`类型（§2.3.4）以及`returnAddress`类型（§2.3.3）。

数字类型包括*整型*（§2.3.1）和*浮点型*（§2.3.2）。

整型包括：

- `byte`，8位二进制有符号整数，默认值为零
- `short`，16位二进制有符号整数，默认值为零
- `int`，32位二进制有符号整数，默认值位零
- `long`，64位二进制有符号整数，默认值位零
- `char`，16位无符号整数，表示基本多文种平面（BMP）中的Unicode代码点，基于UTF-16编码，默认值位null代码点（'`\u0000`'）

浮点型包括：

- `float`，严格遵守IEEE 754中定义的binary32格式，默认值为正零
- `double`，严格遵守IEEE 754中定义的binary64格式，默认值为正零

`boolean`类型就是对`true`和`false`进行编码，默认值是`false`。

<pre>*JVM规范*的第一版中并没有把boolean加入到JVM类型中。但是boolean在JVM中的支持确实有限。从第二版开始明确了这个事情，并把boolean纳入到类型中。</pre>

`returnAddress`类型的值是指向JVM指令操作码（opcode）的指针。在所有的基本类型中，只有`returnAddress`没有直接对应到Java语言的类型上。

## 2.3.1 整型

JVM中的整型值包括：
- `byte`，从-128到127（-2<sup>7</sup>到2<sup>7</sup>-1），闭区间
- `short`，从-32768到32767（-2<sup>15</sup>到2<sup>15</sup>-1），闭区间
- `int`,从-2147483648到2147483647（-2<sup>31</sup>到2<sup>31</sup>-1），闭区间
- `long`,从-9223372036854775808到9223372036854775807（-2<sup>63</sup>到2<sup>63</sup>-1），闭区间
- `char`，从0到65535，闭区间

## 2.3.2 浮点型

浮点型包括`float`和`double`，概念上讲的就是IEEE754的32位binary32以及64位binary64浮点数格式，详见IEEE754标准（JLS §1.7）。

<pre>从JavaSE 15开始，JVM使用了IEEE754标准的2019版。从JavaSE 15之前，使用的是1985版，当时的binary32就叫单精度，binary64叫双精度。</pre>

IEEE754中不仅包括了由符号和量级组成的正负数，还包括正负零，正负*无穷*，以及特殊的*Not-a-Number*值（后来简写成NaN）。NaN用来表示某些无效操作的结果，比如零除以零。`float`和`double`类型的NaN常量都已经预定义了，分别是`Float.NaN`和`Double.NaN`。

浮点数类型的有限非零值都可以表示成s ⋅ m ⋅ 2<sup>(e - N + 1)</sup>的形式，其中：
- s是+1或-1，
- m是小于2<sup>N</sup>的正整数，
- e是一个整数，取值范围是从E<sub>min</sub> = -(2<sup>K-1</sup>-2)到E<sub>max</sub> = 2<sup>K-1</sup>-1，闭区间，且
- N和K是根据类型而定的参数。

有些值可以用多种方式来表达成这种形式。比如，假设浮点数`v`可以用特定的s，m和e，而且恰好m是偶数且e小于2<sup>K-1</sup>，那么用相同的m，然后e加1，就可以构造出值等于`v`的另一种表现形式。

当m ≥ <sup>2N-1</sup>时这种形式称为*规格化浮点数*；否则称为*非规格化浮点数*。如果m ≥ <sup>2N-1</sup>但浮点数无法表示成该形式，则这个值称为*非规格化浮点数*，因为它的量级已经小于规格化最小值的量级了。

在`float`和`double`类型中对于N和K（以及E<sub>min</sub>和E<sub>max</sub>）的约束总结到了表2.3.2-A中。
|  **参数**   | `float`  | `double`  |
|  -  | - | - |
| N | 24 | 53 |
| K | 8 | 11 |
| E<sub>max</sub> | +127 | +1023 |
| E<sub>min</sub> | -126 | -1022 |

除了NaN，浮点数是*有序的*。如果从小到大排序，那就是负无穷，负无穷非零值，正数和正零，正无穷非零值，正无穷。

IEEE754允许binary32和binary64可以有多个不同的NaN值。但是JavaSE会将特定浮点数类型的所有NaN值归结到一个单独的特定值上，因此本书中引用的NaN值对应的是其中任意一种NaN值。

<pre>在IEEE754中，对非NaN参数的浮点数操作可能会生成一个NaN的结果。IEEE754中定义了一组NaN位模式，但是没有强制哪一个NaN位模式用来表达NaN结果；这个事儿交给了硬件架构。程序员可以创建不同位模式的NaN来进行编码，比如可溯源的诊断信息。这些NaN值可以分别用`float`和`double`中对应的`Float.intBitsToFloat`和`Double.longBitsToDouble`方法来创建。反过来，要想看NaN的位模式，可以使用`float`和`double`中对应的`Float.floatToRawIntBits`和`Double.doubleToRawLongBits`方法。</pre>