# 2 JVM结构

本章要定义的是抽象的东西。这里并不介绍JVM的某种特定实现。

要想正确实现JVM，你要做的就是能读懂`class`文件格式，并且能正确的执行它里面要求你干的事儿。JVM规范并不约束其实现细节，这样会限制大家的想象力。比如运行时数据区的内存结构，垃圾回收算法，以及JVM指令的内部优化（比如如何将其翻译成机器代码），这些事儿都分离到具体实现中去了。

本书中使用的Unicode都遵照了*Unicode标准，第13版*，想了解的可以去看`https://www.unicode.org/`。

## 2.1 class文件结构

编译后拿给JVM执行的代码采用了与硬件和操作系统无关的二进制格式，一般（但不是必须）保存再文件中，也就是`class`文件格式。`class`文件格式精确的定义了类或接口的展现形式，包括内部细节，比如特定平台上对象文件格式需要确定它的某种字节序。

第4章“class文件格式”会详细介绍`class`文件格式。

## 2.2 数据类型

和Java语言类似，JVM也会操作两种类型：*基本类型*和*引用类型*。也就是说，变量中保存的，参数所传递的，方法所返回的，以及你可以操作的也就是这两种值：*基本类型值*和*引用类型值*。

JVM希望几乎所有的类型检查都能再运行时之前完成，通常是让编译器完成，而不是让JVM来干。基本类型的值不需要被标记或者具备可探测性才能在运行时判断出它们的类型，也不需要从引用类型的值中区别出来。因为JVM指令集会使用类型特定的指令来区分出它们所操作的操作数的类型。比如`iadd`，`ladd`，`fadd`，`dadd`都属于JVM指令，都是操作两个数字值，并产生一个数字结果，但每一个都有其特定的操作数类型，分别是：`int`，`long`，`float`，`double`。关于JVM指令集中支持的类型可以看§2.11.1。

JVM包含了关于对象的明确支持。一个对象要么是一个动态分配的类实例，要么是一个数组。对象的引用对应JVM中的`reference`类型。`reference`类型的值则被认为是对象的指针。一个对象可以有多个引用。对象的操作、传递和测试总是要基于`reference`类型的值。

## 2.3 基本类型

JVM支持的基本数据类型包括*数字类型*，`boolean`类型（§2.3.4）以及`returnAddress`类型（§2.3.3）。

数字类型包括*整型*（§2.3.1）和*浮点型*（§2.3.2）。

整型包括：

- `byte`，8位二进制有符号整数，默认值为零
- `short`，16位二进制有符号整数，默认值为零
- `int`，32位二进制有符号整数，默认值位零
- `long`，64位二进制有符号整数，默认值位零
- `char`，16位无符号整数，表示基本多文种平面（BMP）中的Unicode代码点，基于UTF-16编码，默认值位null代码点（'`\u0000`'）

浮点型包括：

- `float`，严格遵守IEEE 754中定义的binary32格式，默认值为正零
- `double`，严格遵守IEEE 754中定义的binary64格式，默认值为正零

`boolean`类型就是对`true`和`false`进行编码，默认值是`false`。

<pre>*JVM规范*的第一版中并没有把boolean加入到JVM类型中。但是boolean在JVM中的支持确实有限。从第二版开始明确了这个事情，并把boolean纳入到类型中。</pre>

`returnAddress`类型的值是指向JVM指令操作码（opcode）的指针。在所有的基本类型中，只有`returnAddress`没有直接对应到Java语言的类型上。

## 2.3.1 整型

JVM中的整型值包括：
- `byte`，从-128到127（-2<sup>7</sup>到2<sup>7</sup>-1），闭区间
- `short`，从-32768到32767（-2<sup>15</sup>到2<sup>15</sup>-1），闭区间
- `int`,从-2147483648到2147483647（-2<sup>31</sup>到2<sup>31</sup>-1），闭区间
- `long`,从-9223372036854775808到9223372036854775807（-2<sup>63</sup>到2<sup>63</sup>-1），闭区间
- `char`，从0到65535，闭区间

## 2.3.2 浮点型

浮点型包括`float`和`double`，概念上讲的就是IEEE754的32位binary32以及64位binary64浮点数格式，详见IEEE754标准（JLS §1.7）。

<pre>从JavaSE 15开始，JVM使用了IEEE754标准的2019版。从JavaSE 15之前，使用的是1985版，当时的binary32就叫单精度，binary64叫双精度。</pre>

IEEE754中不仅包括了由符号和量级组成的正负数，还包括正负零，正负*无穷*，以及特殊的*Not-a-Number*值（后来简写成NaN）。NaN用来表示某些无效操作的结果，比如零除以零。`float`和`double`类型的NaN常量都已经预定义了，分别是`Float.NaN`和`Double.NaN`。

浮点数类型的有限非零值都可以表示成s ⋅ m ⋅ 2<sup>(e - N + 1)</sup>的形式，其中：
- s是+1或-1，
- m是小于2<sup>N</sup>的正整数，
- e是一个整数，取值范围是从E<sub>min</sub> = -(2<sup>K-1</sup>-2)到E<sub>max</sub> = 2<sup>K-1</sup>-1，闭区间，且
- N和K是根据类型而定的参数。

有些值可以用多种方式来表达成这种形式。比如，假设浮点数`v`可以用特定的s，m和e，而且恰好m是偶数且e小于2<sup>K-1</sup>，那么用相同的m，然后e加1，就可以构造出值等于`v`的另一种表现形式。

当m ≥ <sup>2N-1</sup>时这种形式称为*规格化浮点数*；否则称为*非规格化浮点数*。如果m ≥ <sup>2N-1</sup>但浮点数无法表示成该形式，则这个值称为*非规格化浮点数*，因为它的量级已经小于规格化最小值的量级了。

在`float`和`double`类型中对于N和K（以及E<sub>min</sub>和E<sub>max</sub>）的约束总结到了表2.3.2-A中。
|  **参数**   | `float`  | `double`  |
|  -  | - | - |
| N | 24 | 53 |
| K | 8 | 11 |
| E<sub>max</sub> | +127 | +1023 |
| E<sub>min</sub> | -126 | -1022 |

除了NaN，浮点数是*有序的*。如果从小到大排序，那就是负无穷，负无穷非零值，正数和正零，正无穷非零值，正无穷。

IEEE754允许binary32和binary64可以有多个不同的NaN值。但是JavaSE会将特定浮点数类型的所有NaN值归结到一个单独的特定值上，因此本书中引用的NaN值对应的是其中任意一种NaN值。

<pre>在IEEE754中，对非NaN参数的浮点数操作可能会生成一个NaN的结果。IEEE754中定义了一组NaN位模式，但是没有强制哪一个NaN位模式用来表达NaN结果；这个事儿交给了硬件架构。程序员可以创建不同位模式的NaN来进行编码，比如可溯源的诊断信息。这些NaN值可以分别用`float`和`double`中对应的`Float.intBitsToFloat`和`Double.longBitsToDouble`方法来创建。反过来，要想看NaN的位模式，可以使用`float`和`double`中对应的`Float.floatToRawIntBits`和`Double.doubleToRawLongBits`方法。</pre>

光拿正零和负零比较，它们是相等的，但依然有别的办法能把它们区分出来；比如`1.0`除以`0.0`得到的是正无穷，`1.0`除以`-0.0`得到的就是负无穷。

NaN是*无序的*，如果对数字做相等判断，只要两个操作数中有一个是NaN，结果就是`false`。而且，只有当值为NaN的时候，判断自己跟自己是否相等，结果一定是`false`。如果是判断不相等，只要俩数中有一个是NaN，结果就是`true`。

### 2.3.3 returnAddress类型

`returnAddress`类型用于JVM的`jsr`、`ret`和`jsr_w`指令（§jsr, §ret, §jsr_w）。`returnAddress`类型的值是JVM指令操作码的指针。与基本数字类型不同，`returnAddress`类型并没有对应到Java语言中的类型，而且无法被运行中的程序所修改。

### 2.3.4 boolean类型

尽管JVM中定义了`boolean`类型，但支持有限。JVM中没有专用于操作`boolean`值的指令。实际上，Java语言中的表达式在操作`boolean`值的时候，编译后都变成了JVM中的`int`类型。

但JVM明确支持`boolean`数组。其中`newarray`指令（§newarray）可以用来创建`boolean`数组。访问和修改`boolean`数组的时候要用到`byte`数组指令中的*baload*和*bastore*（§baload, §bastore）。

<pre>在Oracle的JVM实现中，Java语言的`boolean`数组编码成了JVM的`byte`数组，每个`boolean`元素占8个比特。</pre>

JVM在编码`boolean`数组的时候用`1`代表`true`用`0`代表`false`。Java语言中的`boolean`被编译器映射到了JVM的`int`类型，编译器必须要做相同的编码规则。

## 2.4 引用类型

一共有三种`refrerence`类型：类、数组、接口。它们的值都是在引用动态创建出来的类实例、数组或实现了接口的类实例或数组。

数组类型由*组成类型*和一个单一维度（长度无法由类型给出）组成。数组类型的组成类型也可以是一个数组类型。比如组成类型是个数组类型，那这个数组类型的组成类型还可以是个数组，一直往里套，最终肯定是有一个非数组类型的组成类型；这个就叫做数组类型的*元素类型*。数组类型的元素类型只能是基本类型，或是类，或是接口类型。

`reference`的值也可以是特殊的空引用，也就是没有引用任何对象，这里写作`null`。起初`null`引用时没有运行时类型的，但是可以转换成任意的类型。`reference`类型的默认值就是`null`。

本规范对于`null`并不强制要求某种具体的编码值。

## 2.5 运行时数据区

在程序的执行过程中，JVM定义了大量的运行时数据区。其中部分数据区是在JVM启动的时候创建，而且只有在JVM退出的时候才会销毁。还有每个线程的数据区。线程数据区随着线程的创建而创建，随着线程的退出而销毁。

### 2.5.1 `pc`寄存器

JVM支持同时执行多个线程（JLS§17）。每个JVM线程都有它自己的`pc`（程序计数器）寄存器。在任意的一个时刻，每个JVM线程都在执行一个单独的方法中的代码，被称为该线程的当前方法（§2.6）。如果该方法非`native`方法，`pc`寄存器中包含着当前正在执行的JVM指令的地址。如果线程正在执行的方法是`native`方法，对应JVM的`pc`寄存器中的值则是未定义的。JVM的`pc`寄存器足够宽，可以装得下一个`returnAddress`或者特定平台上的一个本地指针。

### 2.5.2 JVM栈

每个JVM线程都有一个私有的*JVM栈*，和线程一同创建。JVM栈中保存着帧（§2.6）。JVM栈可以类比做编程语言中的栈，比如C中的：它保存了局部变量和局部结果，在方法调用和返回的时候扮演者至关重要的角色。除了帧的压栈和退栈，JVM栈是无法直接操作的，因此帧可以由堆上分配。JVM的栈内存可以是非连续的。

<pre>在JVM规范的第一版中，JVM栈称为*Java栈*。</pre>

本规范允许JVM栈可以是固定大小的，也可以是动态扩展的，根据计算需求按需扩缩。如果JVM栈大小固定，可能就要在栈创建的时候选择各自所需的大小。

<pre>JVM具体实现时可能会为程序猿或用户提供对JVM栈初始大小的控制，以及在动态扩缩过程中可以控制栈尺寸的最大和最小值。</pre>

关于JVM栈，存在以下异常情况：
- 如果线程中的计算所需的JVM栈大小超出了被允许的范围，JVM会抛出一个`StackOverflowError`。
- 如果JVM栈支持动态扩缩，且当前需要扩张，但是没有足够的内存完成扩张，或者在新线程创建的时候就没有足够的内存来创建初始JVM栈，此时JVM就会抛出一个`OutOfMemoryError`。

### 2.5.3 堆

JVM中有一个所有JVM线程共享的*堆*。堆就是用来在运行时分配所有类实例和数组的内存数据区。

JVM启动的时候就会创建堆。对象的堆存储由自动存储管理系统负责回收（也就是*垃圾回收器*）；对象永远不会被显式的回收。JVM不要求自动存储管理系统的具体类型，这部分的奇技淫巧可以由实现者的系统需求来按需选择。堆的大小可以是固定大小，也可以根据计算需要按需扩缩。堆内存可以是非连续的。

<pre>JVM具体实现时可能会为程序猿或用户提供对堆的初始大小的控制，以及在动态扩缩过程中可以控制堆尺寸的最大和最小值。</pre>

关于堆，存在以下异常情况：
- 如果自动存储管理系统无法提供计算所需的堆大小，JVM会抛出一个`OutOfMemoryError`。

### 2.5.4 方法区

JVM包含一个所有JVM线程共享的*方法区*。方法区可以类比做常见编程语言的编译后代码的存储，或者是操作系统进程的“文本”段。它保存了每个类的结构，比如运行时常量池，属性和方法数据，以及方法和构造器的代码，包括类和接口初始化时，以及实例初始化时用到的特殊方法（§2.9）。

方法区在JVM启动的时候创建。尽管方法区在逻辑上也属于堆的一部分，但一些简单的JVM实现可能不会对它进行垃圾回收或者压缩整理。本规范并不强制要求方法区的位置以及用于管理编译后代码的策略。方法区可以时固定大小也可以根据计算需求按需扩缩。方法区的内存可以是非连续的。

<pre>JVM具体实现时可能会为程序猿或用户提供对方法区初始大小的控制，并且在方法区大小可变时允许控制其尺寸的最大最小值。</pre>

关于方法区，存在以下异常情况：
- 如果方法区的可用内存无法满足分配需求，JVM会抛出一个`OutOfMemoryError`。

### 2.5.5 运行时常量池

*运行时常量池*是每个类或接口对`class`文件（§4.4）的`constant_pool`表的表现形式。它包含了若干种常量，包括编译时方法已知的数字字面量，以及必须在运行时解析出的字段引用。运行时常量池用起来像个函数，可以类比做常见编程语言的符号表，尽管它所包含的东西远比普通的符号表要多。

每个运行时常量池都是从JVM方法区（§2.5.4）中分配的。JVM创建每个类或接口时（§5.3）会构建它们的运行时常量池。

关于运行时常量池的构建，存在以下异常情况：
- 当创建一个类或者接口时，如果方法区的可用内存不足以构造其运行时常量池，JVM则会抛出一个`OutOfMemoryError`。

<pre>关于运行时常量池的构建可以去看§5（*加载，链接与初始化*）</pre>

### 2.5.6 本地方法栈

JVM在实现时可能会用传统的栈，也就是坊间所说的“C栈”来支持`native`方法（非Java语言实现的方法）。JVM指令集的语言解释器，比如C语言，在实现时可能也会用到本地方法栈。对于无法加载`native`方法的JVM实现，其本身也不依赖于传统栈，它们也就不需要提供本地方法栈。如果有，本地方法栈一般是在线程创建时每个线程分配一个。

本规范允许本地方法栈可以是固定大小或按需扩缩。如果是固定大小，每个本地方法栈在创建时可以选择各自的大小。

<pre>JVM具体实现时可能会为程序猿或用户提供对本地方法栈初始大小的控制，并且在其大小可变时允许控制其尺寸的最大最小值。</pre>

关于本地方法栈，存在以下异常情况：
- 如果线程中计算所需的本地方法栈大小超出允许的尺寸，JVM会抛出一个`StackOverflowError`。
- 如果本地方法栈允许动态扩展，但是扩展时内存不足，或者是在线程创建时就没有足够的内存来构造初始的本地方法栈，此时JVM会抛出一个`OutOfMemoryError`。

## 2.6 帧

一个*帧*用来保存数据和局部结果，还用于动态链接、方法返回值以及异常分发。

每次进行方法调用时就会创建一个新的帧。当方法调用完成后，帧也随之销毁，不管方法是正常完成还是被中断（抛出了一个未捕获的异常）。帧是在其线程创建帧时从JVM栈（§2.5.2）上分配的。每个帧都有它自己的局部变量（§2.6.1）数组，它自己的操作数栈（§2.6.2），以及一个对当前方法所属类的运行时常量池（§2.5.5）的引用。

<pre>帧可以用其他实现特定的信息进行扩展，比如调试信息。</pre>

局部变量数组和操作数栈的大小在编译时就确定了，提供给了帧所关联的方法代码（§4.7.3）。因此帧数据结构的大小依赖于JVM的具体实现，而且这些结构的内存可以在方法调用时同一时刻分配出来。

每个线程在特定时刻仅有正在执行的方法的帧处于活动状态。这个帧也叫*当前帧*，它所属的方法也就是*当前方法*。方法所属类被称为*当前类*。操作局部变量和操作数栈时一般都引用了当前帧。

当帧所属的方法调用了另一个方法，或者所属方法执行完成，则帧不再属于当前帧。当一个方法被调用时，控制流转移到该方法上时就会创建一个新的帧。当方法返回时，如果方法调用产生了结果，当前帧会传回该结果给上一个帧。然后当前帧就会被丢弃，紧接着上一个帧就变成了当前帧。

注意，线程所创建的帧属于线程局部的，无法被其他线程所引用。

### 2.6.1 局部变量

每个帧（§2.6）包含了一个变量数组，也就是*局部变量*。局部变量数组的长度在编译时就已经确定了，保存到了类或接口的二进制形式中，提供给和帧关联的方法代码（§4.7.3）。

一个局部变量可以持有`boolean`、`byte`、`char`、`short`、`int`、`float`、`reference`或`returnAddress`类型的值。一对儿局部变量可以持有`long`或`double`类型的值。

局部变量通过索引进行寻址。第一个局部变量的索引为零。一个从零到数组长度减一的整数就可以用作局部变量数组的索引。

`long`或`double`类型的值要占用两个连续的局部变量。这种值只能用其中较小的索引来寻址。比如保存在局部变量数组中索引n的一个`double`类型的值，实际上占用了n和n+1位置的局部变量；但是无法直接加载索引位置为n+1的局部变量。可以写入但不能加载。如果是写入，会导致局部变量n的内容失效。

JVM并不要求n必须得是偶数。直观上来说，`long`和`double`类型的值在局部变量数组中无需进行64位对齐。为这种值保留的两个局部变量，在具体实现时，可以随意选用合适的方式来搞。

JVM在方法调用的时候使用局部变量来传参。在类方法调用时，传入的参数就是从0开始的连续的局部变量。在实例方法调用时，局部变量0永远都是一个指向被调用实例方法所属对象的引用（也就是Java语言中的`this`）。传入的参数则是从1开始的连续的局部变量。

### 2.6.2 操作数栈

每个帧（§2.6）都包含了一个后进先出（LIFO）栈，也就是*操作数栈*。操作数栈的最大深度在编译时就确定了，提供给帧所关联的方法代码（§4.7.3）。

如果上下文说的足够明白，我们一般就把当前帧的操作数栈直接称为操作数栈。

帧刚创建好的操作数栈是空的。JVM提供了用于将常量、局部变量值、属性值加载到操作数栈的指令。其他的JVM指令可以从操作数栈中提出操作数，执行操作，并将结果压回到操作数栈。操作数栈还可以用来准备方法的传参以及返回结果的接收。

比如`iadd`指令(§iadd)可以对两个`int`值做相加。它要求这两个值必须位于操作数栈的栈顶，由前置指令完成压栈。这两个`int`值都会从栈中弹出。对它们求和后将结果压回到操作数栈。操作数栈上可能还嵌套着其他内部计算，为外部计算提供可用的结果。

操作数栈的每一条信息都可以持有一个任意JVM类型的值，包括`long`或`double`类型的值。

对操作数栈中的值进行操作时，必须要符合对应值的类型。比如你放入了两个`int`值，然后想当`long`用，这肯定不行，比如你放入了两个`float`值，然后想用`iadd`指令对它俩进行求和，也行不通。有少数几个JVM指令（`dup`（§dup）和`swap`（§swap））可以对运行时数据区按原始值进行操作，不用管它们的具体类型；这些指令在定义的时候要求它们不会修改或截断某个值。这些关于操作数栈的使用方面的规则通过`class`文件校验（§4.10）实现强制要求。

在任一时刻，操作数栈都关联了一个深度，一个`long`或`double`类型的值占两个深度单位，其他类型的值占一个深度单位。

### 2.6.3 动态链接

每个帧（§2.6）为当前方法的类型包含了一个运行时常量池（§2.5.5）的引用，为方法代码提供*动态链接*能力。`class`文件中通过符号引用来实现方法间的应用调用以及变量访问。动态链接将这些符号方法引用翻译成具体的方法引用，加载所需的类来解析尚未定义的符号，将变量访问翻译到这些变量在运行时对应的存储结构的偏移量上。

这种方法和变量的后绑定机制，在修改方法所使用的其他类的时候，破坏其代码的可能性更低。

### 2.6.4 方法调用正常结束

如果方法调用没有抛出异常（§2.10），不管是JVM抛的还是直接执行`throw`语句抛的，方法调用就被认为是*正常结束*。如果当前方法调用正常结束，可能还会给调用方返回一个值。正常结束的前提是被调用方法执行了其中一种返回指令（§2.11.8），如果有返回值的话，选择的返回指令必须要适用于返回值的类型。

此时，当前帧（§2.6）用来恢复调用者的状态，包括它的局部变量和操作数栈，以及调用者的程序计数器要从方法调用指令跳到下一个适当的位置。调用者的帧继续正常执行，如果被调用者有返回值，要把返回值压入帧的操作数栈。

### 2.6.5 方法调用异常结束

如果方法内的JVM指令导致JVM抛出异常（§2.10），并且方法没有处理异常，则方法调用*异常结束*。执行`athrow`指令（§athrow）会显式抛出异常，如果当前方法没有捕获该异常，则方法执行被中断。被中断的方法不会返回值给调用者。

## 2.7 对象的表现形式

对于对象的内部结构，JVM并不做强制要求。

<pre>在一些Oracle的JVM中，对于类实例的而引用就是一个*句柄*的指针，而这个句柄本身又是一对儿指针：其中一个指向一张表，里面包含了对象的方法，以及一个指向该对象所属类型的Class对象的指针，另一个指向了为该对象数据分配的堆内存。</pre>

## 2.8 浮点数运算

JVM中包含了一部分IEEE 754标准中定义的浮点数运算（JLS §1.7）。

<pre>从JavaSE15开始，JVM使用2019版的IEEE 754标准。在这之前，JVM用的是1985版的，当时binary32被称为单精度，binary64则是双精度。</pre>

JVM中很多算术运算（§2.11.3）和类型转换（§2.11.4）指令都可以用于浮点数。这些指令一般都遵照IEEE 754的行为规范（表2.8-A），后面也给出了一些例外情况。

**表 2.8-A IEEE 754参照**

|指令|IEEE 754操作|
|-|-|
|dcmp<op> (§dcmp<op>), fcmp<op> (§fcmp<op>)|compareQuietLess, compareQuietLessEqual, compareQuietGreater, compareQuietGreaterEqual, compareQuietEqual, compareQuietNotEqual|
|dadd (§dadd), fadd (§fadd)|addition|
|dsub (§dsub), fsub (§fsub)|subtraction|
|dmul (§dmul), fmul (§fmul)|multiplication|
|ddiv (§ddiv), fdiv (§fdiv)|division|
|dneg (§dneg), fneg (§fneg)|negate|
|i2d (§i2d), i2f (§i2f), l2d (§l2d), l2f (§l2f)|convertFromInt|
|d2i (§d2i), d2l (§d2l), f2i (§f2i), f2l (§f2l)|convertToIntegerTowardZero|
|d2f (§d2f), f2d (§f2d)|convertFormat|

JVM和IEEE 754中浮点数运算的关键不同之处在于：

- 浮点数取余指令*drem*（§drem）和*frem*（§frem）跟IEEE 754中的不一样。我们的指令是基于向零舍入的隐式除法；人家的则是就近舍入的隐式除法。（后面会讲舍入策略。）
- 浮点数的负数指令*dneg*（§dneg）和*fneg*（§fneg）跟IEEE 754的不一样。特别是，如果被转换的是一个NaN，则指令并不需要它的符号位。
- JVM的浮点数指令不会抛异常，不会陷入（trap）以及IEEE 754中其他的异常情况的信号，比如无效操作、除以零、上溢、下溢和非精确值。
- JVM不支持IEEE 754的信号浮点数比较，并且没有信号NaN值。
- IEEE 754的舍入方向属性不适用于JVM的舍入策略。JVM中无法修改浮点数指令所使用的舍入策略。
<pre>某些IEEE 754操作在JVM中没有对应的属性，这些操作都封到了<code>Math</code>和<code>StrictMath</code>类中，包括IEEE 754的平方根操作<code>sqrt</code>，融合乘加运算方法<code>fma</code>，以及IEEE 754的求余操作<code>IEEEremainder</code>方法。</pre>

JVM需要IEEE 754中的*非正规*浮点数以及*逐渐下溢*，这样才能更好的证明一些特殊的数值算法中的期望属性。

浮点数运算是实数运算的一个近似。虽然实数可以有无限多个，但特定的浮点数格式只能有固定数量的值。在JVM中，*舍入策略*就是以特定格式将一个实数映射到一个浮点数的一个函数。处于一个浮点数格式下可表示范围内的实数，实数线内的一个连续的段会被映射到一个单一的浮点数值。数值上跟一个浮点数值相等的实数会被映射到这个浮点数值上；比如实数1.5以指定格式映射到浮点数1.5。JVM中定义了两种舍入策略：

- *就近舍入*，适用于所有浮点数指令，除了（1）转换成整数以及（2）求余。在这种策略下，非精确结果必须舍入到离无限精确结果最接近的可表达的值上；如果有两个可表达的值，接近程度相同，则选择最低有效位为零的值。<br/>就近舍入策略符合IEEE 754中二进制运算的默认舍入方向属性：*roundTiesToEven*，舍入到偶数。

<pre><i>roundTiesToEven</i>，这种舍入方向属性，也就是1985版IEEE 754标准中的“就近舍入”模式。JVM中的舍入策略是以该舍入模式命名的。</pre>

- *向零舍入*，这种舍入策略应用于（1）将浮点数值用`d2i`、`d2l`、`f2i`和`f2l`指令转换成整数，以及（2）浮点数求余指令`drem`和`frem`。在这种策略下，非精确结果舍入到最近的量级不大于无限精确结果的可表达的值。如果是转换成整数，向零舍入等同于截断，丢弃了小数部分的有效数位。<br/>向零舍入策略符合IEEE 754中二进制运算的<code>roundTowardZero</code>舍入方向属性。

<pre><i>rountTowardZero</i>，这种舍入方向属性，也就是1985版IEEE 754标准中的“向零舍入”模式。JVM中的舍入策略是以该摄入模式命名的。</pre>

JVM要求每个浮点数指令都要将它的结果舍入到结果精度。根据上面说的，每个指令用的舍入策略要么是就近要么是向零。

Java 1.0和1.1要求浮点数表达式要做*严格*运算。严格运算意味着每个`float`操作数都要对应一个IEEE 754中binary32格式的可表达的值，每个`double`操作数要对应一个binary64格式的可表达的值，每个浮点数操作符要对应一个IEEE 754中的操作，其结果要跟IEEE 754对应操作的结果一样。

严格运算提供了可预测的结果，但是在Java 1.0/1.1时代，JVM实现的时候在某些处理器系列中出现了性能问题。结果就是，从Java 1.2开始到JavaSE 16，JavaSE平台允许JVM实现的时候为每个浮点数类型关联一到两个*值集*。`float`类型关联了*float值集*和*float扩展指数值集*，`double`类型也是关联了*double值集*和*double扩展指数值集*。float值集对应IEEE 754的binary32格式中可表达的值；float扩展指数值集拥有相同的精度位数量，但是指数范围更大。同理，double值集对应IEEE 754的binary64格式中可表达的值；double扩展指数值集拥有相同的精度位数量，但是指数范围更大。有了扩展指数值集就可以改善某些处理器系列中遇到的性能问题。

处于兼容性考虑，Java 1.2允许一个`class`文件禁止实现中使用扩展指数值集。`class`文件通过在方法声明时设置`ACC_STRICT`标志来实现这一点。`ACC_STRICT`约束了方法中的指令使用`float`操作数的float值集时的浮点数语义，以及`double`操作数的double值集，保证这些指令的结果是完全可预测的。标记了`ACC_STRICT`的方法，它的浮点数语义跟在Java 1.0和1.1中声明时是一样的。

从JavaSE 17开始，JavaSE平台总是要求浮点数表达式做严格运算。干这种事儿有困难的那些处理器系列中的新成员们也不再有这种困境了。本规范不再为`float`和`double`提供上面讲的四种值集，`ACC_STRICT`标志也不再会影响浮点数操作的计算了。出于兼容性考虑，在major版本号46~60的`class`文件中`ACC_STRICT`设置的位模式，在major版本号大于60的`class`文件中不再设置（也就是不再标记任何标志）（§4.6）。在以后的JVM中，`class`文件中的这部分位模式可能会赋予新的含义。

## 2.9 特殊方法

### 2.9.1 实例初始化方法

每个类都有零或多个*实例初始化方法*，每个都对应Java语言中的一个构造方法。

当一个方法满足以下所有条件时它就是一个实例初始化方法：
- 它定义在一个类中（而非接口）。
- 它的名字是`<init>`。
- 它返回`void`（§4.3.3）。

在一个类中，任何非`void`但名为`<init>`的方法都不是实例初始化方法。在一个接口中，任何名为`<init>`的方法都不是实例初始化方法。这种方法无法被任何JVM指令调用（§4.4.2, §4.9.2），直接就被格式检查给拒了（§4.6, §4.8）。

实例初始化方法的声明和使用都被JVM约束着。声明的时候，方法的`access_flags`和`code`数组都被约束着（§4.6, §4.9.2）。使用的话，一个实例初始化方法只能在未初始化的类实例上用`invokespecial`指令来调用（§4.10.1.9）。

<pre>由于<code>&lt;init&gt;</code>这个名字在Java语言中属于无效的标识符，所以在Java语言的程序中无法直接使用。</pre>

### 2.9.2 类初始化方法

一个类或接口最多只能有一个*类或接口初始化方法*，由JVM完成该方法的调用（§5.5）。

当以下条件成立时，该方法就是*类或接口初始化方法*：
- 有着特殊的名字`<clinit>`。
- 是`void`的（§4.3.3）。
- 如果`class`文件的版本号大于等于51.0，该方法应该有`ACC_STATIC`标志，但是方法不带参数（§4.6）。

<pre><code>ACC_STATIC</code>这玩意是JavaSE 7带进来的，在JavaSE 9中不再带参数了。如果class文件版本号小于等于50.0，方法名为<code>&lt;clinit&gt;</code>且是<code>void</code>的就被认为是类或接口初始化方法了，不管有没有<code>ACC_STATIC</code>标志，不管带不带参数。</pre>

`class`文件中的其他名为`<clinit>`的方法不算是类或接口初始化方法。JVM永远也不会调用它们，无法被任何JVM指令调用（§4.9.1），在格式检查的时候也会被拒（§4.6, §4.8）。

<pre>由于<code>&lt;clinit&gt;</code></pre>在Java语言中不属于有效的标识符，所以在Java语言中无法直接使用。

### 2.9.3 签名多态方法

如果一个方法是*签名多态*的，则应满足以下条件：
- 它声明在`java.lang.invoke.MethodHandle`或`java.lang.invoke.VarHandle`类中。
- 只有一个类型为`Object[]`的形参。
- 有`ACC_VARARGS`和`ACC_NATIVE`标志。

为了对*方法句柄*的调用施加影响，或是对`java.lang.invoke.VarHandle`实例引用的变量访问施加影响，JVM在`invokevirtual`指令中对签名多态方法做了特殊处理。

一个方法句柄是一个动态的，强类型的，可直接执行的引用，它可以引用一个方法、构造器、字段或是类似的低级别操作（§5.4.3.5），还可以对参数或返回值做变形处理。一个`java.lang.invoke.VarHandle`的实例也是一个动态的，强类型的引用，它可以引用一个或一组变量，包括`static`字段、非`static`字段、数组元素或是非堆数据结构的组成部分。详见JavaSE API的`java.lang.invoke`包。

## 2.10 异常

JVM中的异常用`Throwable`类或其子类的实例来表达。一个异常的抛出会导致在抛出位置立即发生一次非局部控制转移。

大部分异常都是所在线程中某个动作的结果导致的，并且是同步发生的。相反，如果是异步异常，可能发生在程序执行的任何地方。JVM抛出异常的原因无非是下面三个之一：
- 执行了`athrow`指令。
- JVM同步探测到了一个异常的执行条件。这些异常并不会在程序中的任意一点抛出，而是在下面两种指令之一执行后同步抛出：
    - 将异常声明为一种可能的结果，比如：
        - 指令导致操作违反了Java语言的语义，比如索引到了数组界限范围之外。
        - 程序加载或者链接的时候发生错误。
    - 导致某些资源使用超限，比如内存消耗过多。
- 由于以下原因导致一个异步异常：
    - 调用了`Thread`或`ThreadGroup`的`stop`方法，或
    - JVM内部实现上发生了错误。<br/>`stop`方法可能是被某个线程调用来影响另一个线程，或者另一个线程组中的所有线程。它们是异步的，因为它们可能发生在其他线程执行的任一时刻。此外，内部错误的发生也被认为是异步的（§6.3）。

JVM可能允许在异步异常抛出之前搞一些小动作。有了这个小空挡，优化后的代码就可以发现并将这些异常在更切实际的位置进行抛出，而且还不会违背Java语言的语义。

<pre>简单的JVM实现可能会在每一处控制转移指令上轮询异步异常。因为程序的大小是有限的，这样做就可以对探测异步异常整体需要花费的时间定下一个界限。因为在两个控制转移之间是不会有异步异常的，因此代码生成器就可以非常灵活的在这期间对计算进行重新排序，从而获取更好的性能。建议大家去看看*Polling Efficiently on Stock Hardware by Marc Feeley, Proc. 1993 Conference on
Functional Programming and Computer Architecture*。</pre>

JVM的异常抛出是很讲究的：当发生控制转移时，异常抛出点之前的所有指令必须看上去已经生效了。异常抛出点之后的指令必须看上去没有计算过。如果优化后的代码推测执行了某些在异常点之后的指令，那这些代码必须要准备好让它干的这些事儿无法被用户察觉。

JVM中的每个方法可能会关联零个或多个*异常处理器*。一个异常处理器声明了相关方法在JVM中实现代码的偏移量范围，描述了该异常处理器所能处理的异常类型，声明了用来处理异常的代码位置。一个异常要想匹配上异常处理器，导致该异常的指令偏移量必须在异常声明的偏移量范围内，且异常的类型要么和异常处理器声明的类型一致要么是其子类。当异常抛出时，JVM会在当前方法内搜索匹配的异常处理器。如果找到了一个，则系统会转移到异常处理器声明的相关处理代码上。

如果当前方法内找不到匹配的异常处理器，则当前方法调用被中断（§2.6.5）。此时，当前方法的操作数栈和局部变量会被丢弃，对应的帧被弹出，恢复调用者的帧。然后异常会在调用者帧的上下文中重新抛出，随着方法调用链一直往上走。如果在到达调用链顶端之前一直没有找到合适的异常处理器，则异常所在的线程被终止执行。

如何搜索匹配的异常处理器也是很讲究的。在`class`文件中，每个方法的异常处理器都保存在一个表中（§4.7.3）。在运行时，如果出现异常，JVM为当前方法搜索异常处理器的时候，是按照它们在该表中的顺序来搜索的，从该表的开头顺着往后找。

JVM并不对方法内异常表的记录顺序和嵌套规则做强制要求。Java语言中的异常处理语义实现时只跟编译器打交道（§3.12）。如果`class`文件通过其他手段生成，其中定义好的搜索过程保证了所有JVM实现时都是一致的。

## 2.11 指令集汇总

每个JVM指令包含一个单字节的*opcode*，定义要执行的操作，然后跟零个或多个*operand*，为操作提供所需的参数或数据。很多指令不需要操作数，只有一个操作码。

不考虑异常情况，JVM解释器内部的循环机制基本上是这样的

```
do {
    if (operands) 
    atomically calculate pc and fetch opcode at pc;
    if (operands) fetch operands;
    execute the action for the opcode;
} while (there is more to do);
```

操作数的数量和大小是由操作符决定的。如果一个操作数大于一字节，那就用*大端序*保存——高位在前。比如一个无符号16位索引，那它就用两个无符号字节来保存，*byte1*和*byte2*，它的值就是`(byte1 << 8) | byte2`。

字节码指令流只做单字节对齐。两个特殊的情况是*lookupswitch*和*tableswitch*指令，它们的某些操作数要在四字节边界上强制补齐。

<pre>将JVM操作码先知道一个字节并且放弃在编译后的代码中做字节对齐，这体现了非常明显的对于紧凑感的偏爱，甚至在某些简单实现中还要损耗一些性能。一字节的操作码同样限制了指令集的大小。不做数据对齐意味着大于一字节的即时数据在很多机器上需要在运行时通过多字节构建。</pre>

### 2.11.1 类型与JVM

JVM指令集中的大部分指令都编码了它们各自操作的类型信息。比如*iload*指令，加载局部变量到操作数栈，要求变量必须得是`int`。*fload*指令则是对应`float`值。这两个指令的实现可能是一样的，但是操作码却不同。

对于大部分带类型的指令，指令的类型都是将对应的助记字母放在操作码中：*i*就是`int`操作，*l*就是`long`，*s*是`short`，*b*是`byte`，*c*是`char`，*f*是`float`，*d*是`double`，*a*是`reference`。有些指令其类型特征很明显，就不用加助记字母了。比如*arraylength*肯定是操作数组的。其他的指令，比如*goto*，做的是无条件控制转移，不需要操作带类型的操作数。

由于JVM操作码的单字节大小限制，如何将类型信息编码到操作码中，这对于指令集的设计提出了很高的要求。如果每个带类型的指令都要支持JVM的所有运行时数据类型，那一字节肯定不够用了。因此，JVM对某些操作的类型支持做了降级处理。也就是说指令集故意不做正交设计。部分指令可以根据需要在支持和不支持的类型之间进行转换。

表2.11.1-A中总结了JVM指令集的类型支持情况。每个带类型的指令将操作码列中指令模板中的*T*替换成类型列的信息。如果指令模板对应的类型列为空，那就是该类型没有对应的指令。比如`int`有加载指令*iload*，但是`byte`就没有。

我们注意到表2.11.1-A中的大部分指令都不怎么支持`byte`、`char`和`short`。也都不支持`boolean`类型。编译器对`byte`和`short`类型的字面量加载做编码时，用JVM指令对它们的值进行符号扩展，在编译时或运行时弄成`int`类型。`boolean`和`char`类型的字面量加载，则是通过指令编码在编译时或运行时做零扩展，也弄成`int`类型。同样，对于`boolean`、`byte`、`short`和`char`类型的数组，也是在编译时或运行时通过JVM指令编码做符号扩展或零扩展，弄成`int`类型的值。因此，对于真实类型为`boolean`、`byte`、`char`和`short`类型的值，都可以被`int`类型的指令正确的处理。

|**操作码**|`byte`|`short`|`int`|`long`|`float`|`double`|`char`|`reference`|
|-|-|-|-|-|-|-|-|-|
|*Tipush*|*bipush*|*sipush*|||||||
|*Tconst*|||*iconst*|*lconst*|*fconst*|*dconst*||*aconst*|
|*Tload*|||*iload*|*lload*|*fload*|*dload*||*aload*|
|*Tstore*|||*istore*|*lstore*|*fstore*|*dstore*||*astore*|
|*Tinc*|||*iinc*||||||
|*Taload*|*baload*|*saload*|*iaload*|*laload*|*faload*|*daload*|*caload*|*aaload*|
|*Tastore*|*bastore*|*sastore*|*iastore*|*lastore*|*fastore*|*dastore*|*castore*|*aastore*|
|*Tadd*|||*iadd*|*ladd*|*fadd*|*dadd*|||
|*Tsub*|||*isub*|*lsub*|*fsub*|*dsub*|||
|*Tmul*|||*imul*|*lmul*|*fmul*|*dmul*|||
|*Tdiv*|||*idiv*|*ldiv*|*fdiv*|*ddiv*|||
|*Trem*|||*irem*|*lrem*|*frem*|*drem*|||
|*Tneg*|||*ineg*|*lneg*|*fneg*|*dneg*|||
|*Tshl*|||*ishl*|*lshl*|||||
|*Tshr*|||*ishr*|*lshr*|||||
|*Tushr*|||*iushr*|*lushr*|||||
|*Tand*|||*iand*|*land*|||||
|*Tor*|||*ior*|*lor*|||||
|*Txor*|||*ixor*|*lxor*|||||
|*i2T*|*i2b*|*i2s*||*i2l*|*i2f*|*i2d*|||
|*l2T*|||*l2i*||*l2f*|*l2d*|||
|*f2T*|||*f2i*|*f2l*||*f2d*|||
|*d2T*|||*d2i*|*d2l*|*d2f*||||
|*Tcmp*||||*lcmp*|||||
|*Tcmpl*|||||*fcmpl*|*dcmpl*|||
|*Tcmpg*|||||*fcmpg*|*dcmpg*|||
|*if_TcmpOP*|||*if_icmpOP*|||||*if_acmpOP*|
|*Treturn*|||*ireturn*|*lreturn*|*freturn*|*dreturn*|||*areturn*|

JVM真实类型和计算类型的映射关系总结在了表2.11.1-B中。

某些JVM指令，比如*pop*和*swap*，它们在操作数栈上的动作是与类型无关的；这些指令只能用于一部分计算类型范畴，在表2.11.1-B中给出。

**表 2.11.1-B JVM中的真实类型和计算类型**

|**真实类型**|**计算类型**|**范畴**|
|-|-|-|
|boolean|int|1|
|byte|int|1|
|char|int|1|
|short|int|1|
|int|int|1|
|float|float|1|
|reference|reference|1|
|returnAddress|returnAddress|1|
|long|long|2|
|double|double|2|

### 2.11.2 加载和存储指令

加载和存储指令在JVM帧中的局部变量（§2.6.1）和操作数栈（§2.6.2）之间来回转移各种值。
- 加载一个局部变量到操作数栈：*iload*，*iload_&lt;n&gt;*，*lload*，*lload_&lt;n&gt;*，*fload*，*fload_&lt;n&gt;*，*dload*，*dloadl_&lt;n&gt;*，*aload*，*aload_&lt;n&gt;*。
- 从操作数栈存储一个变量到局部变量：*istore*，*istore_&lt;n&gt;*，*lstore*，*lstore_&lt;n&gt;*，*fstore*，*fstore_&lt;n&gt;*，*dstore*，*dstore_&lt;n&gt;*，*astore*，*astore_&lt;n&gt;*。
- 加载一个常量到操作数栈：*bipush*，*sipush*，*ldc*，*ldc_w*，*ldc2_w*，*aconst_null*，*iconst_m1*，*iconst_&lt;i&gt;*，*lconst_&lt;l&gt;*，*fconst_&lt;f&gt;*，*dconst_&lt;d&gt;*。
- 通过更宽的索引获取更多局部变量的访问权限，或者更大的快速操作：*wide*。

访问对象属性和数组元素（§2.11.5）的时候也是要跟操作数栈打交道的。

上面列出的这些指令，其中带下划线及尖括号的（比如*iload_&lt;n&gt;*），表示了一个指令族（比如*iload_&lt;n&gt;*就包含了*iload_0*，*iload_1*，*iload_2*，*iload_3*）。这种指令族都属于一般指令（*iload*）的特殊化形式，自己直接就带了一个操作数。对于这些特殊化指令，操作数是隐式的，不用做存储或提取，但语义是一样的（*iload_0*就等于*iload*带一个操作数*0*）。尖括号中的字母表示指令族对应的隐式类型：&lt;n&gt;就是非负整数；&lt;i&gt;是`int`；&lt;l&gt;是`long`；&lt;f&gt;是`float`，&lt;d&gt;是`double`。`int`类型的这些格式使用场景相对多一些，因为它们还用来处理`byte`、`char`和`short`（§2.11.1）。

这种标记法将贯穿本书。

### 2.11.3 运算指令

运算指令都要计算出一个结果，基本上就是一个函数，带着两个来自操作数栈的值，然后将结果压回操作数栈。主要有两种运算指令：操作整数的和操作浮点数的。每种类型中，运算指令都要特殊化成JVM类型专用的指令。对于`byte`、`short`、`char`（§2.11.1）或`boolean`类型，没有直接的整数运算支持；它们的操作都是用`int`类型的操作来完成。整数和浮点数指令还有别于溢出处理和被零除时的处理方式。运算指令列表如下：
- 加：*iadd*、*ladd*、*fadd*、*dadd*
- 减：*isub*、*lsub*、*fsub*、*dsub*
- 乘：*imul*、*lmul*、*fmul*、*dmul*
- 除：*idiv*、*ldiv*、*fdiv*、*ddiv*
- 求余：*irem*、*lrem*、*frem*、*drem*
- 求负：*ineg*、*lneg*、*fneg*、*dneg*
- 移位：*ishl*、*ishr*、*iushr*、*lshl*、*lshr*、*lushr*
- 按位或：*ior*、*lor*
- 按位与：*iand*、*land*
- 按位异或：*ixor*、*lxor*
- 局部变量递增：*iinc*
- 比较：*dcmpg*、*dcmpl*、*fcmpg*、*fcmpl*、*lcmp*

Java语言中整数和浮点数（JLS §4.2.2, JLS §4.2.4）的操作符语义直接由JVM指令集的语义支持。

JVM处理整数类型的时候并没有对溢出情况做出假设。整数操作里能抛异常的只有整数除法指令（*idiv*和*ldiv*）和整数求余指令（*irem*和*lrem*），当除数为零的时候抛出`ArithmeticException`。

JVM处理浮点数类型的时候并没有对上溢和下溢做出假设。也就是说浮点数指令永远不会导致JVM抛出一个运行时异常（不要跟IEEE 754浮点数异常搞混）。如果操作导致上溢则得到一个有符号的无穷大；如果操作导致下溢则得到一个非规格化值或者有符号的零；如果操作无法得到唯一的数学上定义的结果，则得到一个NaN。所有的数字操作如果其中一个操作数为NaN，则结果也是NaN。

对于`long`类型的比较（*lcmp*）做的是有符号比较。

对于浮点数类型（*dcmpg*、*dcmpl*、*fcmpg*、*fcmpl*）的比较用的是IEEE 754的非符号化比较。

### 2.11.4 类型转换指令

类型转换指令用于JVM类型间的转换。这玩意可以用来实现在用户代码中的显式转换，或者用来缓解JVM指令集中正交性不足的地方。

JVM直接支持了以下放大型的数字类型转换：
- `int`到`long`、`float`或`double`
- `long`到`float`或`double`
- `float`到`double`

这些放大型的转换指令分别是*i2l*、*i2f*、*i2d*、*l2f*、*l2d*、*f2d*。这些助记符都可以望文生义，很直接，类型简写，中间夹个2，表示“to”。比如*i2d*就是`int`到`double`的转换。

大部分这些放大型的数字类型转换都不会丢失其值的量级大小。确实，从`int`放大到`long`、从`int`放大到`double`都不会丢失任何信息；数值都被精确的保留下来。从`float`放大到`double`也一样。

如果是从`int`到`float`、`long`到`float`、`long`到`double`，这些可能会丢失*精度*，也就是丢失最低有效位；得到的结果就是其整数值舍入后的浮点数值，用的是就近舍入策略（§2.8）。

尽管可能会丢失精度，但放大型的数值转换绝对不会导致JVM抛出运行时异常（不要跟IEEE 754的浮点数异常搞混）。

对于`int`到`long`的放大，直接就是把`int`值的符号位往大拉，拉到足够宽的位置即可。对于`char`到整数类型的放大，那就是给`char`值填零，填到足够宽的位置。

注意，并不存在从`byte`、`char`、`short`到`int`类型的转换。由§2.11.1可知，`byte`、`char`、`short`实际上内部已经拓宽成了`int`，隐式的搞了这种转换。

JVM还直接支持了以下的减肥型转换：
- `int`到`byte`、`short`或`char`
- `long`到`int`
- `float`到`int`或`long`
- `double`到`int`、`long`或`float`

这种往小了抽抽的类型转换指令包括*i2b*、*i2c*、*i2s*、*l2i*、*f2i*、*f2l*、*d2i*、*d2l*以及*d2f*。往小抽抽可能会导致结果的符号、数量级发生变化并因此而丢失精度。

如果是从`int`或`long`往整数类型*T*抽抽，直接就是只保留最低的*n*位，剩下的全丢弃，这里的*n*位就用来表达类型*T*。这样就会出现结果和输入值的符号不一样的情况了。

如果是从浮点数值往整数类型*T*抽抽，且*T*是`int`或`long`，则按以下规则转换：
- 如果浮点数是NaN，结果则是`int`或`long`型的`0`。
- 否则，如果浮点数非无穷大，则按照向零舍入策略（§2.8）将浮点数舍入到整数值`v`。此时又分为两种情况：
    - 如果*T*是`long`，且得到的整数值可以表达成一个`long`，那么结果值`v`就是个`long`。
    - 如果*T*是`int`，且得到的整数值可以表达成一个`int`，那么结果值`v`就是个`int`。
- 否则：
    - 要么值太小（很大量级的负数或负无穷），得到的结果就是`int`或`long`的最小值表达。
    - 要么值太大（很大量级的正数或正无穷），得到的结果就是`int`或`long`的最大值表达。

从`double`往`float`类型抽抽转换参照IEEE 754的规则。转换结果使用就近舍入原则（§2.8）。如果值太小，无法表达成一个`float`的话，则会转换成`float`类型的正零或负零；如果值太大，则会转换成正或负无穷。`double`类型的NaN转换成`float`后还是NaN。

尽管会有上下溢、丢精度的问题，往小抽抽这种类型转换绝对不会导致JVM抛异常（不要跟IEEE 754的浮点数异常搞混了）。