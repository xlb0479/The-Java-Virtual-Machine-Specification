# 2 JVM结构

本章要定义的是抽象的东西。这里并不介绍JVM的某种特定实现。

要想正确实现JVM，你要做的就是能读懂`class`文件格式，并且能正确的执行它里面要求你干的事儿。JVM规范并不约束其实现细节，这样会限制大家的想象力。比如运行时数据区的内存结构，垃圾回收算法，以及JVM指令的内部优化（比如如何将其翻译成机器代码），这些事儿都分离到具体实现中去了。

本书中使用的Unicode都遵照了*Unicode标准，第13版*，想了解的可以去看`https://www.unicode.org/`。

## 2.1 class文件结构

编译后拿给JVM执行的代码采用了与硬件和操作系统无关的二进制格式，一般（但不是必须）保存再文件中，也就是`class`文件格式。`class`文件格式精确的定义了类或接口的展现形式，包括内部细节，比如特定平台上对象文件格式需要确定它的某种字节序。

第4章“class文件格式”会详细介绍`class`文件格式。

## 2.2 数据类型

和Java语言类似，JVM也会操作两种类型：*基本类型*和*引用类型*。也就是说，变量中保存的，参数所传递的，方法所返回的，以及你可以操作的也就是这两种值：*基本类型值*和*引用类型值*。

JVM希望几乎所有的类型检查都能再运行时之前完成，通常是让编译器完成，而不是让JVM来干。基本类型的值不需要被标记或者具备可探测性才能在运行时判断出它们的类型，也不需要从引用类型的值中区别出来。因为JVM指令集会使用类型特定的指令来区分出它们所操作的操作数的类型。比如`iadd`，`ladd`，`fadd`，`dadd`都属于JVM指令，都是操作两个数字值，并产生一个数字结果，但每一个都有其特定的操作数类型，分别是：`int`，`long`，`float`，`double`。关于JVM指令集中支持的类型可以看§2.11.1。

JVM包含了关于对象的明确支持。一个对象要么是一个动态分配的类实例，要么是一个数组。对象的引用对应JVM中的`reference`类型。`reference`类型的值则被认为是对象的指针。一个对象可以有多个引用。对象的操作、传递和测试总是要基于`reference`类型的值。

## 2.3 基本类型

JVM支持的基本数据类型包括*数字类型*，`boolean`类型（§2.3.4）以及`returnAddress`类型（§2.3.3）。

数字类型包括*整型*（§2.3.1）和*浮点型*（§2.3.2）。

整型包括：

- `byte`，8位二进制有符号整数，默认值为零
- `short`，16位二进制有符号整数，默认值为零
- `int`，32位二进制有符号整数，默认值位零
- `long`，64位二进制有符号整数，默认值位零
- `char`，16位无符号整数，表示基本多文种平面（BMP）中的Unicode代码点，基于UTF-16编码，默认值位null代码点（'`\u0000`'）

浮点型包括：

- `float`，严格遵守IEEE 754中定义的binary32格式，默认值为正零
- `double`，严格遵守IEEE 754中定义的binary64格式，默认值为正零

`boolean`类型就是对`true`和`false`进行编码，默认值是`false`。

<pre>*JVM规范*的第一版中并没有把boolean加入到JVM类型中。但是boolean在JVM中的支持确实有限。从第二版开始明确了这个事情，并把boolean纳入到类型中。</pre>

`returnAddress`类型的值是指向JVM指令操作码（opcode）的指针。在所有的基本类型中，只有`returnAddress`没有直接对应到Java语言的类型上。

## 2.3.1 整型

JVM中的整型值包括：
- `byte`，从-128到127（-2<sup>7</sup>到2<sup>7</sup>-1），闭区间
- `short`，从-32768到32767（-2<sup>15</sup>到2<sup>15</sup>-1），闭区间
- `int`,从-2147483648到2147483647（-2<sup>31</sup>到2<sup>31</sup>-1），闭区间
- `long`,从-9223372036854775808到9223372036854775807（-2<sup>63</sup>到2<sup>63</sup>-1），闭区间
- `char`，从0到65535，闭区间

## 2.3.2 浮点型

浮点型包括`float`和`double`，概念上讲的就是IEEE754的32位binary32以及64位binary64浮点数格式，详见IEEE754标准（JLS §1.7）。

<pre>从JavaSE 15开始，JVM使用了IEEE754标准的2019版。从JavaSE 15之前，使用的是1985版，当时的binary32就叫单精度，binary64叫双精度。</pre>

IEEE754中不仅包括了由符号和量级组成的正负数，还包括正负零，正负*无穷*，以及特殊的*Not-a-Number*值（后来简写成NaN）。NaN用来表示某些无效操作的结果，比如零除以零。`float`和`double`类型的NaN常量都已经预定义了，分别是`Float.NaN`和`Double.NaN`。

浮点数类型的有限非零值都可以表示成s ⋅ m ⋅ 2<sup>(e - N + 1)</sup>的形式，其中：
- s是+1或-1，
- m是小于2<sup>N</sup>的正整数，
- e是一个整数，取值范围是从E<sub>min</sub> = -(2<sup>K-1</sup>-2)到E<sub>max</sub> = 2<sup>K-1</sup>-1，闭区间，且
- N和K是根据类型而定的参数。

有些值可以用多种方式来表达成这种形式。比如，假设浮点数`v`可以用特定的s，m和e，而且恰好m是偶数且e小于2<sup>K-1</sup>，那么用相同的m，然后e加1，就可以构造出值等于`v`的另一种表现形式。

当m ≥ <sup>2N-1</sup>时这种形式称为*规格化浮点数*；否则称为*非规格化浮点数*。如果m ≥ <sup>2N-1</sup>但浮点数无法表示成该形式，则这个值称为*非规格化浮点数*，因为它的量级已经小于规格化最小值的量级了。

在`float`和`double`类型中对于N和K（以及E<sub>min</sub>和E<sub>max</sub>）的约束总结到了表2.3.2-A中。
|  **参数**   | `float`  | `double`  |
|  -  | - | - |
| N | 24 | 53 |
| K | 8 | 11 |
| E<sub>max</sub> | +127 | +1023 |
| E<sub>min</sub> | -126 | -1022 |

除了NaN，浮点数是*有序的*。如果从小到大排序，那就是负无穷，负无穷非零值，正数和正零，正无穷非零值，正无穷。

IEEE754允许binary32和binary64可以有多个不同的NaN值。但是JavaSE会将特定浮点数类型的所有NaN值归结到一个单独的特定值上，因此本书中引用的NaN值对应的是其中任意一种NaN值。

<pre>在IEEE754中，对非NaN参数的浮点数操作可能会生成一个NaN的结果。IEEE754中定义了一组NaN位模式，但是没有强制哪一个NaN位模式用来表达NaN结果；这个事儿交给了硬件架构。程序员可以创建不同位模式的NaN来进行编码，比如可溯源的诊断信息。这些NaN值可以分别用`float`和`double`中对应的`Float.intBitsToFloat`和`Double.longBitsToDouble`方法来创建。反过来，要想看NaN的位模式，可以使用`float`和`double`中对应的`Float.floatToRawIntBits`和`Double.doubleToRawLongBits`方法。</pre>

光拿正零和负零比较，它们是相等的，但依然有别的办法能把它们区分出来；比如`1.0`除以`0.0`得到的是正无穷，`1.0`除以`-0.0`得到的就是负无穷。

NaN是*无序的*，如果对数字做相等判断，只要两个操作数中有一个是NaN，结果就是`false`。而且，只有当值为NaN的时候，判断自己跟自己是否相等，结果一定是`false`。如果是判断不相等，只要俩数中有一个是NaN，结果就是`true`。

### 2.3.3 returnAddress类型

`returnAddress`类型用于JVM的`jsr`、`ret`和`jsr_w`指令（§jsr, §ret, §jsr_w）。`returnAddress`类型的值是JVM指令操作码的指针。与基本数字类型不同，`returnAddress`类型并没有对应到Java语言中的类型，而且无法被运行中的程序所修改。

### 2.3.4 boolean类型

尽管JVM中定义了`boolean`类型，但支持有限。JVM中没有专用于操作`boolean`值的指令。实际上，Java语言中的表达式在操作`boolean`值的时候，编译后都变成了JVM中的`int`类型。

但JVM明确支持`boolean`数组。其中`newarray`指令（§newarray）可以用来创建`boolean`数组。访问和修改`boolean`数组的时候要用到`byte`数组指令中的*baload*和*bastore*（§baload, §bastore）。

<pre>在Oracle的JVM实现中，Java语言的`boolean`数组编码成了JVM的`byte`数组，每个`boolean`元素占8个比特。</pre>

JVM在编码`boolean`数组的时候用`1`代表`true`用`0`代表`false`。Java语言中的`boolean`被编译器映射到了JVM的`int`类型，编译器必须要做相同的编码规则。

## 2.4 引用类型

一共有三种`refrerence`类型：类、数组、接口。它们的值都是在引用动态创建出来的类实例、数组或实现了接口的类实例或数组。

数组类型由*组成类型*和一个单一维度（长度无法由类型给出）组成。数组类型的组成类型也可以是一个数组类型。比如组成类型是个数组类型，那这个数组类型的组成类型还可以是个数组，一直往里套，最终肯定是有一个非数组类型的组成类型；这个就叫做数组类型的*元素类型*。数组类型的元素类型只能是基本类型，或是类，或是接口类型。

`reference`的值也可以是特殊的空引用，也就是没有引用任何对象，这里写作`null`。起初`null`引用时没有运行时类型的，但是可以转换成任意的类型。`reference`类型的默认值就是`null`。

本规范对于`null`并不强制要求某种具体的编码值。

## 2.5 运行时数据区

在程序的执行过程中，JVM定义了大量的运行时数据区。其中部分数据区是在JVM启动的时候创建，而且只有在JVM退出的时候才会销毁。还有每个线程的数据区。线程数据区随着线程的创建而创建，随着线程的退出而销毁。

### 2.5.1 `pc`寄存器

JVM支持同时执行多个线程（JLS§17）。每个JVM线程都有它自己的`pc`（程序计数器）寄存器。在任意的一个时刻，每个JVM线程都在执行一个单独的方法中的代码，被称为该线程的当前方法（§2.6）。如果该方法非`native`方法，`pc`寄存器中包含着当前正在执行的JVM指令的地址。如果线程正在执行的方法是`native`方法，对应JVM的`pc`寄存器中的值则是未定义的。JVM的`pc`寄存器足够宽，可以装得下一个`returnAddress`或者特定平台上的一个本地指针。

### 2.5.2 JVM栈

每个JVM线程都有一个私有的*JVM栈*，和线程一同创建。JVM栈中保存着帧（§2.6）。JVM栈可以类比做编程语言中的栈，比如C中的：它保存了局部变量和局部结果，在方法调用和返回的时候扮演者至关重要的角色。除了帧的压栈和退栈，JVM栈是无法直接操作的，因此帧可以由堆上分配。JVM的栈内存可以是非连续的。

<pre>在JVM规范的第一版中，JVM栈称为*Java栈*。</pre>

本规范允许JVM栈可以是固定大小的，也可以是动态扩展的，根据计算需求按需扩缩。如果JVM栈大小固定，可能就要在栈创建的时候选择各自所需的大小。

<pre>JVM具体实现时可能会为程序猿或用户提供对JVM栈初始大小的控制，以及在动态扩缩过程中可以控制栈尺寸的最大和最小值。</pre>

关于JVM栈，存在以下异常情况：
- 如果线程中的计算所需的JVM栈大小超出了被允许的范围，JVM会抛出一个`StackOverflowError`。
- 如果JVM栈支持动态扩缩，且当前需要扩张，但是没有足够的内存完成扩张，或者在新线程创建的时候就没有足够的内存来创建初始JVM栈，此时JVM就会抛出一个`OutOfMemoryError`。

### 2.5.3 堆

JVM中有一个所有JVM线程共享的*堆*。堆就是用来在运行时分配所有类实例和数组的内存数据区。

JVM启动的时候就会创建堆。对象的堆存储由自动存储管理系统负责回收（也就是*垃圾回收器*）；对象永远不会被显式的回收。JVM不要求自动存储管理系统的具体类型，这部分的奇技淫巧可以由实现者的系统需求来按需选择。堆的大小可以是固定大小，也可以根据计算需要按需扩缩。堆内存可以是非连续的。

<pre>JVM具体实现时可能会为程序猿或用户提供对堆的初始大小的控制，以及在动态扩缩过程中可以控制堆尺寸的最大和最小值。</pre>

关于堆，存在以下异常情况：
- 如果自动存储管理系统无法提供计算所需的堆大小，JVM会抛出一个`OutOfMemoryError`。

### 2.5.4 方法区

JVM包含一个所有JVM线程共享的*方法区*。方法区可以类比做常见编程语言的编译后代码的存储，或者是操作系统进程的“文本”段。它保存了每个类的结构，比如运行时常量池，属性和方法数据，以及方法和构造器的代码，包括类和接口初始化时，以及实例初始化时用到的特殊方法（§2.9）。

方法区在JVM启动的时候创建。尽管方法区在逻辑上也属于堆的一部分，但一些简单的JVM实现可能不会对它进行垃圾回收或者压缩整理。本规范并不强制要求方法区的位置以及用于管理编译后代码的策略。方法区可以时固定大小也可以根据计算需求按需扩缩。方法区的内存可以是非连续的。

<pre>JVM具体实现时可能会为程序猿或用户提供对方法区初始大小的控制，并且在方法区大小可变时允许控制其尺寸的最大最小值。</pre>

关于方法区，存在以下异常情况：
- 如果方法区的可用内存无法满足分配需求，JVM会抛出一个`OutOfMemoryError`。

### 2.5.5 运行时常量池

*运行时常量池*是每个类或接口对`class`文件（§4.4）的`constant_pool`表的表现形式。它包含了若干种常量，包括编译时方法已知的数字字面量，以及必须在运行时解析出的字段引用。运行时常量池用起来像个函数，可以类比做常见编程语言的符号表，尽管它所包含的东西远比普通的符号表要多。

每个运行时常量池都是从JVM方法区（§2.5.4）中分配的。JVM创建每个类或接口时（§5.3）会构建它们的运行时常量池。

关于运行时常量池的构建，存在以下异常情况：
- 当创建一个类或者接口时，如果方法区的可用内存不足以构造其运行时常量池，JVM则会抛出一个`OutOfMemoryError`。

<pre>关于运行时常量池的构建可以去看§5（*加载，链接与初始化*）</pre>

### 2.5.6 本地方法栈

JVM在实现时可能会用传统的栈，也就是坊间所说的“C栈”来支持`native`方法（非Java语言实现的方法）。JVM指令集的语言解释器，比如C语言，在实现时可能也会用到本地方法栈。对于无法加载`native`方法的JVM实现，其本身也不依赖于传统栈，它们也就不需要提供本地方法栈。如果有，本地方法栈一般是在线程创建时每个线程分配一个。

本规范允许本地方法栈可以是固定大小或按需扩缩。如果是固定大小，每个本地方法栈在创建时可以选择各自的大小。

<pre>JVM具体实现时可能会为程序猿或用户提供对本地方法栈初始大小的控制，并且在其大小可变时允许控制其尺寸的最大最小值。</pre>

关于本地方法栈，存在以下异常情况：
- 如果线程中计算所需的本地方法栈大小超出允许的尺寸，JVM会抛出一个`StackOverflowError`。
- 如果本地方法栈允许动态扩展，但是扩展时内存不足，或者是在线程创建时就没有足够的内存来构造初始的本地方法栈，此时JVM会抛出一个`OutOfMemoryError`。

## 2.6 帧

一个*帧*用来保存数据和局部结果，还用于动态链接、方法返回值以及异常分发。

每次进行方法调用时就会创建一个新的帧。当方法调用完成后，帧也随之销毁，不管方法是正常完成还是被中断（抛出了一个未捕获的异常）。帧是在其线程创建帧时从JVM栈（§2.5.2）上分配的。每个帧都有它自己的局部变量（§2.6.1）数组，它自己的操作数栈（§2.6.2），以及一个对当前方法所属类的运行时常量池（§2.5.5）的引用。

<pre>帧可以用其他实现特定的信息进行扩展，比如调试信息。</pre>

局部变量数组和操作数栈的大小在编译时就确定了，提供给了帧所关联的方法代码（§4.7.3）。因此帧数据结构的大小依赖于JVM的具体实现，而且这些结构的内存可以在方法调用时同一时刻分配出来。

每个线程在特定时刻仅有正在执行的方法的帧处于活动状态。这个帧也叫*当前帧*，它所属的方法也就是*当前方法*。方法所属类被称为*当前类*。操作局部变量和操作数栈时一般都引用了当前帧。

当帧所属的方法调用了另一个方法，或者所属方法执行完成，则帧不再属于当前帧。当一个方法被调用时，控制流转移到该方法上时就会创建一个新的帧。当方法返回时，如果方法调用产生了结果，当前帧会传回该结果给上一个帧。然后当前帧就会被丢弃，紧接着上一个帧就变成了当前帧。

注意，线程所创建的帧属于线程局部的，无法被其他线程所引用。

### 2.6.1 局部变量

每个帧（§2.6）包含了一个变量数组，也就是*局部变量*。局部变量数组的长度在编译时就已经确定了，保存到了类或接口的二进制形式中，提供给和帧关联的方法代码（§4.7.3）。

一个局部变量可以持有`boolean`、`byte`、`char`、`short`、`int`、`float`、`reference`或`returnAddress`类型的值。一对儿局部变量可以持有`long`或`double`类型的值。

局部变量通过索引进行寻址。第一个局部变量的索引为零。一个从零到数组长度减一的整数就可以用作局部变量数组的索引。

`long`或`double`类型的值要占用两个连续的局部变量。这种值只能用其中较小的索引来寻址。比如保存在局部变量数组中索引n的一个`double`类型的值，实际上占用了n和n+1位置的局部变量；但是无法直接加载索引位置为n+1的局部变量。可以写入但不能加载。如果是写入，会导致局部变量n的内容失效。

JVM并不要求n必须得是偶数。直观上来说，`long`和`double`类型的值在局部变量数组中无需进行64位对齐。为这种值保留的两个局部变量，在具体实现时，可以随意选用合适的方式来搞。

JVM在方法调用的时候使用局部变量来传参。在类方法调用时，传入的参数就是从0开始的连续的局部变量。在实例方法调用时，局部变量0永远都是一个指向被调用实例方法所属对象的引用（也就是Java语言中的`this`）。传入的参数则是从1开始的连续的局部变量。

### 2.6.2 操作数栈

每个帧（§2.6）都包含了一个后进先出（LIFO）栈，也就是*操作数栈*。操作数栈的最大深度在编译时就确定了，提供给帧所关联的方法代码（§4.7.3）。

如果上下文说的足够明白，我们一般就把当前帧的操作数栈直接称为操作数栈。

帧刚创建好的操作数栈是空的。JVM提供了用于将常量、局部变量值、属性值加载到操作数栈的指令。其他的JVM指令可以从操作数栈中提出操作数，执行操作，并将结果压回到操作数栈。操作数栈还可以用来准备方法的传参以及返回结果的接收。

比如`iadd`指令(§iadd)可以对两个`int`值做相加。它要求这两个值必须位于操作数栈的栈顶，由前置指令完成压栈。这两个`int`值都会从栈中弹出。对它们求和后将结果压回到操作数栈。操作数栈上可能还嵌套着其他内部计算，为外部计算提供可用的结果。

操作数栈的每一条信息都可以持有一个任意JVM类型的值，包括`long`或`double`类型的值。

对操作数栈中的值进行操作时，必须要符合对应值的类型。比如你放入了两个`int`值，然后想当`long`用，这肯定不行，比如你放入了两个`float`值，然后想用`iadd`指令对它俩进行求和，也行不通。有少数几个JVM指令（`dup`（§dup）和`swap`（§swap））可以对运行时数据区按原始值进行操作，不用管它们的具体类型；这些指令在定义的时候要求它们不会修改或截断某个值。这些关于操作数栈的使用方面的规则通过`class`文件校验（§4.10）实现强制要求。

在任一时刻，操作数栈都关联了一个深度，一个`long`或`double`类型的值占两个深度单位，其他类型的值占一个深度单位。

### 2.6.3 动态链接

