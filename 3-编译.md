# 3 编译

JVM被设计用来支持Java编程语言。Oracle的JDK包含了一个从Java语言到JVM指令集的编译器，以及一个运行时系统，实现了JVM。理解编译器如何利用JVM，对于后来的编译器开发者，以及那些想要了解JVM本身的人们，是很有用的。本章中的编号章节并非规范性内容。

注意，术语“编译器”有的时候指的是从JVM指令集到特定CPU指令集的翻译器。这种翻译器之一就是即时（JIT）代码生成器，它在JVM代码被加载后生成平台相关的指令。本章并不涉及这种代码生成相关的内容，只介绍从Java语言源码到JVM指令的编译。

## 3.1 栗子格式

本章包含了大量的源代码示例，以及加了注释的JVM代码，这些JVM代码是由1.0.2版本Oracle JDK编译器生成的。这些JVM代码使用“虚拟机汇编语言”，由Oracle的`javap`工具生成，这是JDK发行版自带的工具。你自己用`javap`也能生成其它的栗子。

如果你读过汇编语言代码，那这些栗子的格式你应该会很熟悉。每条指令都是这种格式：
```
<index> <opcode> [ <operand1> [ <operand2>... ]] [<comment>]
```

`<index>`是该指令操作码在对应方法的JVM字节码数组中的索引。也可以把它认为是在该方法中的一个字节偏移量。`<opcode>`是指令操作码的助记符号，然后是零或多个`<operandN>`代表指令的操作数。`<comment>`则是放在末尾的注释内容：
```
8 bipush 100 // Push int constant 100
```

注释里面有些东西是`javap`生成的；其它的则是作者加的。每条指令前的`<index>`可能会被用作控制转移指令的目标。比如一个*goto 8*指令就可以将控制转移到索引8对应的指令上。注意，JVM控制转移指令真正的操作数实际上是对应指令操作码的地址偏移量；`javap`（本章到处都是）把这些操作数都搞成更加易读的这种偏移量的形式放到了方法里。

我们先来看这样一个操作数，它代表一个运行时常量池索引，带了一个井号，然后指令后面跟着一段注释，标明运行时常量池中被引用的元素，如下：

```
10 ldc #1 // Push float constant 100.0
```
或：
```
9 invokevirtual #4 // Method Example.addTwo(II)I
```

我们紧抓本章的主题，至于操作数的大小我们无需指明。

## 3.2 常量、本地变量与控制结构的使用

通过对各种类型的设计和加以运用，JVM代码展示了一系列通用的特性。我们首先来看这样一个栗子，这个栗子我们也经常遇到，现在我们要深挖一下。

下面的`spin`方法执行一个空循环100次：

```java
void spin() {
    int i;
    for (i = 0; i < 100; i++) {
        ; // Loop body is empty
    }
}
```

编译器可以将`spin`编译成这样：

```
0 iconst_0 // Push int constant 0
1 istore_1 // Store into local variable 1 (i=0)
2 goto 8 // First time through don't increment
5 iinc 1 1 // Increment local variable 1 by 1 (i++)
8 iload_1 // Push local variable 1 (i)
9 bipush 100 // Push int constant 100
11 if_icmplt 5 // Compare and loop if less than (i < 100)
14 return // Return void when done
```

JVM是面向栈的，大部分操作都需要从JVM当前帧的操作数栈上拿出至少一个操作数，或者是将运算结果压回操作数栈。每次调用方法时，都穿创建一个新的帧，随之也创建了一个方法所需的新的操作数栈和一个局部变量集合（§2.6）。因此，在任一时刻，每个控制线程都包含了大量的帧和同样多的操作数栈，对应着大量的方法嵌套调用。只有当前帧的操作数栈是处于活动状态的。

JVM指令集对不同数据类型的操作使用不同的字节码，从而对不同的操作数类型加以区分。上面的方法`spin`只操作了`int`类型的值。在编译后的代码中，用的指令都是`int`类型特定的指令（iconst_0, istore_1, iinc, iload_1, if_icmplt）。

`spin`中的`0`和`100`这两个常量，压栈的时候用了不同的指令。压`0`用的是*iconst_0*指令，它属于*iconst_&lt;i&gt;*指令族。压`100`用的是`bipush`指令，它把它的操作数作为一种即时操作数，提出它的值并进行压栈。

JVM频繁利用了某些高频操作数的特点（`int`常量*-1*,*0*,*1*,*2*,*3*,*4*,*5*都属于*iconst_&lt;i&gt;*），这样操作码中就可以直接隐式包含了操作数。因为*iconst_0*指令知道它要压的就是`int 0`，所以它不需要把这个值提前保存到某个操作数中，也不需要从操作数中提值或解码什么的。如果把压`0`编译成*bipush 0*也对，但是最终的`spin`代码就会多出一个字节来。如果是一个比较简易的虚拟机，每次循环可能还会花费额外的时间对显式操作数提值和解码。用了隐式操作数，编译后的代码更加紧凑高效。

`spin`中的`int i`保存为JVM的局部变量*1*。由于大部分JVM指令操作的值都是从操作数栈弹出来的，而不是直接操作局部变量，所以在局部变量和操作数栈之间来回倒腾也成为了JVM编译后代码中非常常见的场景。这些操作在指令集中也提供了特殊的支持。在`spin`中，操作数从局部变量转移时，使用了*istore_1*和*iload_1*指令，它们都是在隐式操作局部变量*1*。*istore_1*是从操作数栈弹出一个`int`然后把它保存到局部变量*1*中。*iload_1*指令则是将局部变量*1*的值压入操作数栈。

对于局部变量的使用（重用）是编译器编写者们的工作。这些特殊的读写指令可以让编译器编写者们更加灵活的对局部变量进行重用。生成的结果代码也就更快，更紧凑，占用的帧空间也更小。

JVM对这些局部变量的高频操作提供了大量的福利。*iinc*指令可以将局部变量的值递增一个单字节有符号值。`spin`中的*iinc*指令将第一个局部变量（指令的第一个操作数）递增了*1*（指令的第二个操作数）。*iinc*指令在实现循环结构的时候特别好使。

`spin`中的`for`循环主要是靠这些指令实现的：

```
5 iinc 1 1 // Increment local variable 1 by 1 (i++)
8 iload_1 // Push local variable 1 (i)
9 bipush 100 // Push int constant 100
11 if_icmplt 5 // Compare and loop if less than (i < 100)
```

*bipush*将*100*作为一个`int`压入操作数栈，*if_icmplt*则是从操作数栈中弹出这个值然后将它跟*i*比较。如果比较成功（`i`小于`100`），控制转移到索引*5*处，开始`for`循环的下一个迭代。否则继续*if_icmplt*后面的指令。

如果`spin`不用`int`类型做累加器，编译后的代码肯定也要变。比如用`double`：
```java
void dspin() {
    double i;
    for (i = 0.0; i < 100.0; i++) {
        ; // Loop body is empty
    }
}
```

编译后：
```
Method void dspin()
0 dconst_0 // Push double constant 0.0
1 dstore_1 // Store into local variables 1 and 2
2 goto 9 // First time through don't increment
5 dload_1 // Push local variables 1 and 2
6 dconst_1 // Push double constant 1.0
7 dadd // Add; there is no dinc instruction
8 dstore_1 // Store result in local variables 1 and 2
9 dload_1 // Push local variables 1 and 2
10 ldc2_w #4 // Push double constant 100.0
13 dcmpg // There is no if_dcmplt instruction
14 iflt 5 // Compare and loop if less than (i < 100.0)
17 return // Return void when done
```

现在这些指令都变成`double`专用的了。（后面会讲*ldc2_w*指令。）

我们前面讲过，`double`值要占两个局部变量的位置，访问的时候用二者中较低的索引。`long`也是如此。再看这个栗子：
```java
double doubleLocals(double d1, double d2) {
    return d1 + d2;
}
```
编译后
```
Method double doubleLocals(double,double)
0 dload_1 // First argument in local variables 1 and 2
1 dload_3 // Second argument in local variables 3 and 4
2 dadd
3 dreturn
```
注意`double`用的一对儿局部变量，永远不能拆开单独使用。

JVM操作码大小为1个字节，在编译后的代码中会变得非常紧凑。但是1字节的操作码就意味着整个JVM指令集也很小。因此JVM并没有为所有数据类型都提供相等判断：非完全正交（表2.11.1-A）。

比如上面的栗子中，`int`的相等判断可以用一个`if_icmplt`指令；但是`double`的话一个指令就不够了。索引`dspin`就要用*dcmpg*加*iflt*指令一起来实现`double`值的比较。

JVM给`int`提供的直接支持是最多的。部分原因是为了让JVM的操作数栈以及局部变量数组在实现上更加高效。而且还考虑到`int`类型在一般的程序中最为常用。其它整数类型的直接支持就很少了。比如`byte`、`char`、`short`都没有存储、加载或相加指令。下面我们把`spin`改成`short`的：
```java
void sspin() {
    short i;
    for (i = 0; i < 100; i++) {
        ; // Loop body is empty
    }
}
```
编译后操作的很有可能是`int`，然后还要在`short`和`int`之间来回转换，保证`short`类型的操作结果仍然保持在正确的范围内：
```
Method void sspin()
0 iconst_0
1 istore_1
2 goto 10
5 iload_1 // The short is treated as though an int
6 iconst_1
7 iadd
8 i2s // Truncate int to short
9 istore_1
10 iload_1
11 bipush 100
13 if_icmplt 5
16 return
```
对于`byte`、`char`、`short`类型缺少直接支持并没有什么损害，因为这些值都会被升级成`int`（`byte`和`short`做有符号扩展，char做零值扩展）。然后它们的操作就直接用`int`的指令就可以了。唯一的额外消耗就是要把`int`操作的结果截断到有效的范围内。

`long`和浮点数类型的支持度居中，只是在有条件控制转移指令上缺少一定的支持。