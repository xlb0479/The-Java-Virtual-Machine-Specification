# 5 加载，链接与初始化

JVM会动态加载、链接、初始化类和接口。加载就是找到指定名字的类或接口类型的二进制表达，然后
根据二进制表达*创建*这个接口或类。链接就是把一个类或接口并入JVM的运行时状态，这样才能够执行。类或接口的初始化包含了类或接口的初始化方法`<clinit>`（§2.9.2）的执行。

在本章中，（嘿嘿，终于弄完了第四章）§5.1讲的是JVM如何从类或接口的二进制表达中获取符号引用。§5.2讲的是JVM是如何启动加载、链接以及初始化过程的。§5.3给出类和接口的二进制表达是如何被类加载器加载以及类和接口是如何被创建的。§5.4讲链接。§5.5会详细说说类和接口的初始化。§5.6介绍本地方法的绑定。最后，§5.7会说一下JVM是什么时候退出的。

## 5.1 运行时常量池

JVM为每个类和接口维护了一个运行时常量池（§2.5.5）。这个数据结构为常见编程语言的符号表提供了大量支持。类或接口的二进制表达中的`constant_pool`表（§4.4）用来在类或接口创建时构造运行时常量池（§5.3）。

在运行时常量池中一共有两种记录：符号引用，后期会做解析（§5.4.3），以及静态常量，不需要进一步处理。

运行时常量池中的符号引用来自于`constant_pool`表中的记录，跟里面的结构一致：

- 对类或接口的符号引用来自于`CONSTANT_Class_info`结构体（§4.4.1）。这种引用按照下面的形式给出类或接口䣌名字：
    - 对于非数组类或接口，名字就是类或接口的二进制名（§4.2.1）。
    - 对于*n*维数组类，名字开头是*n*个ASCII字符`[`，然后是它的元素类型：
        - 如果元素类型是基本类型，则用对应的字段描述符（§4.3.2）表达。
        - 否则，如果元素类型是引用类型，则用ASCII字符`L`开头，然后是元素类型的二进制名，然后跟一个ASCII字符`;`。

&emsp;&emsp;本章中提到类或接口的名字时，都应该理解为上面说的这种格式。（这也是`Class.getName`方法返回的格式。）

- 对类或接口字段的符号引用来自于`CONSTANT_Fieldref_info`结构体（§4.4.2）。这种引用给出了字段的名字和描述符，以及该字段所属的类或接口的符号引用。
- 对类中方法的符号引用来自`CONSTANT_Methodref_info`结构体（§4.4.2）。这个引用给出了方法的名字和描述符，以及到该方法所属类的符号引用。
- 对接口中方法的符号引用来自于`CONSTANT_InterfaceMethodref_info`结构体（§4.4.2）。这个引用给出了接口方法的名字和描述符，以及方法所在接口的符号引用。
- 方法句柄的符号引用来自于`CONSTANT_MethodHandle_info`结构体（§4.4.8）。这个引用给出了类或接口字段的符号引用，或者是类方法符号引用，也可能是接口方法的符号引用，要看方法句柄的类型。
- 方法类型的符号引用来自于`CONSTANT_MethodType_info`结构体（§4.4.9）。这个引用给出了方法描述符（§4.3.3）。
- *动态计算常量*的符号引用来自于`CONSTANT_Dynamic_info`结构体（§4.4.10）。这种符号引用提供了：
    - 到方法句柄的符号引用，用来计算常量的值；
    - 一个符号引用和静态常量序列，方法句柄调用的时候作为*静态参数*。
    - 一个未限定名和一个字段描述符。

运行时常量池中的静态常量还同样来自于`constant_pool`表，和其中每条记录的结构保持一致：

- 字符串常量是`String`类实例的一个`reference`，它来自于`CONSTANT_String_info`结构体（§4.4.3）。要搞出一个字符串常量，JVM要检查`CONSTANT_String_info`结构体给出的代码点序列：
    - 如果某个`String`类实例的`String.intern`方法被调用过，并且它包含的Unicode代码点序列跟当前`CONSTANT_String_info`结构体给出的一样，那么这个字符串常量就是同一个`String`类实例的`reference`。
    - 否则，就创建一个新的`String`类的实例，包含该`CONSTANT_String_info`结构体给出的Unicode代码点序列。该字符串常量就是对这个新实例的一个`reference`。最终，在这个新实例上调用`String.intern`方法。
- 数字常量来自于`CONSTANT_Integer_info`、`CONSTANT_Float_info`、`CONSTANT_Long_info`以及`CONSTANT_Double_info`结构体（§4.4.4，§4.4.5）。

&emsp;&emsp;注意`CONSTANT_Float_info`结构体代表的是IEEE754的单精度格式值，`CONSTANT_Double_info`结构体代表的是IEEE754的双精度格式值。因此，从这些结构体搞出来的数值常量必须要用IEEE754单精度或双精度格式来表达。

`constant_pool`表中其余的结构体——描述性的结构体`CONSTANT_NameAndType_info`、`CONSTANT_Module_info`、`CONSTANT_Package_info`，以及基础型的结构体`CONSTANT_Utf8_info`——只在构建运行时常量池时间接用到。运行时常量池中不存在跟这些结构体直接对应的记录。

运行时常量池中某些记录是*可加载的*，也就是说：

- 它们可以被*ldc*系列指令压栈（§ldc，§ldc_w，§ldc2_w）。
- 它们可以是动态计算常量和调用点的引导方法的静态参数（§5.4.3.6）。

如果`constant_pool`表中的记录是可加载的（见表4.4-C），那么用它搞出来的运行时常量池记录也是可加载的。以此类推，运行时常量池中的以下记录都是可加载的：

- 类和接口的符号引用
- 方法句柄的符号引用
- 动态计算常量的符号引用
- 静态常量

## 5.2 JVM启动

JVM启动的时候要用引导类加载器（§5.3.1）或用户自定义类加载器（§5.3.2）创建一个初始类或接口。然后JVM为这个初始类或接口做链接，初始化，然后调用`public static`方法`void main(String[])`。该方法的调用派生出后续的所有操作。组成`main`方法的JVM指令的执行可能会链接（并创建）其他的类和接口，并调用其它的方法。

这个初始类或接口要以实现特定的方式来定义。比如这个初始类或接口可以被作为一个命令行参数。或者，JVM在实现的时候自己可以提供一个初始类，用它创建一个类加载器，然后再返回来加载一个应用。只要是按照前面讲的规范来，初始类或接口也可以干其它的事儿。

## 5.3 创建与加载

要创建一个名为*N*的类或接口*C*，就是要在JVM方法区（§2.5.4）中创建出与实现相关的*C*的内部表达。

类或接口的创建被另一个类或接口*D*触发，而它的运行时常量池通过名字*N*符号引用了*C*（§5.4.3.1）。如果*N*指的不是数组类，那么JVM就要用一个*类加载器*来定位一个名为*N*的类或接口的二进制表达（§4.1）。当类加载器定位到了二进制表达，它要反过来依赖JVM从这个二进制表达中搞出类或接口*C*，然后在方法区中创建*C*。数组类不具备外部二进制表达；JVM创建它们的时候走了不同的流程。

&emsp;&emsp;<sub>类或接口的创建还可以通过*D*调用某些JavaSE平台类库（§2.12）来触发，比如反射。</sub>

一共有两种类加载器：JVM提供的引导类加载器，以及用户定义的类加载器。用户定义的类加载器都属于是抽象类`ClassLoader`的子类的实例。应用借助用户定义的类加载器来扩展JVM动态创建类时的行为。用户定义的类加载器可以用自定义的源来创建类。比如一个类可以从网络上下载下来，在运行时生成出来，或者是从某个加密文件中提取出来。

当JVM请求一个类加载器*L*定位一个名为*N*的类或接口时，*L*要加载*N*代表的类或接口*C*。*L*可以直接加载*C*，定位到二进制表达并请求JVM从二进制表达中创建出*C*。或者也可以间接加载，委派给另一个类加载器，对方可以直接或间接的加载*C*。

如果是直接加载，我们就说*L* *定义了* *C*，或者说*L*是*C*的*定义加载器*。

不管是直接还是间接，我们说*L* *启动了* *C*的加载，或者也可以说*L*是*C*的*启动加载器*。

由于类加载器的委派机制，依JVM请求启动加载的加载器<i>L<sub>1</sub></i>，跟完成类或接口定义加载的加载器<i>L<sub>2</sub></i>，可能不是同一个。此时，我们说<i>L<sub>1</sub></i>和<i>L<sub>2</sub></i>都*启动了* *C*的加载，或者说<i>L<sub>1</sub></i>和<i>L<sub>2</sub></i>都是*C*的*启动加载器*。在<i>L<sub>1</sub></i>和<i>L<sub>2</sub></i>之间委派链上的其它加载器并不被当成是*C*的启动加载器。

有的时候我们会用下面的标记法来表达一个类或接口，而不是用*C*或*D*这种标识符：

- <code>&lt;<i>N</i>, <i>L<sub>d</sub></i>&gt;</code>——其中*N*代表类或接口名，<i>L<sub>d</sub></i>代表类或接口的定义加载器。
- <code><i>N<sup>L<sub>i</sub></sup></i></code>——其中*N*代表类或接口名，<i>L<sub>i</sub></i>代表类或接口的启动加载器。

&emsp;&emsp;<sub>需要说明的是类或接口的*加载*是JVM和类加载器（如果出现委派，可能有多个类加载器）共同的努力成果。加载过程最终的结果就是JVM在方法区中创建了一个类或接口，所以我们也常说一个类或接口*因为加载所以创建*。</sub>

&emsp;&emsp;<sub>加载过程这种反反复复的复杂本质，加上还能让用户自定义类加载器来展示各种行为，意味着在JVM创建一个类或接口*之后*，在每个参与加载的类加载器完成*之前*，是可以抛出异常的。这种定义考虑到了我们常说的*类或接口的加载与创建过程*中的异常。</sub>

JVM采用以下三种方式之一来创建类或接口*D*的运行时常量池中名为*N*的类或接口*C*：

- 如果*N*代表的是非数组类或接口，而且*D*是由引导类加载器定义的，那么引导类加载器启动*C*的加载（§5.3.1）。
- 如果*N*代表的是非数组类或接口，而且*D*是由用户定义的类加载器所定义的，那么就是同样的用户自定义类加载器来启动*C*的加载（§5.3.2）。
- 如果*N*代表一个数组类，那么JVM在*D*的定义加载器配合下创建*N*所指定的数组类*C*。

&emsp;&emsp;<sub>尽管*D*的定义加载器跟数组类的创建过程有关，但是并不用它来加载和创建数组类。</sub>

如果在类或接口的加载过程中——类加载器定位到二进制表达的时候，或者是JVM从二进制表达中创建类的时候——出错了，那么这个错误必须在程序中（直接或间接）用到当前被加载的类或接口时抛出来。

&emsp;&emsp;<sub>正常工作的类加载器应当具备这三种属性：<ul><li>给你同样的名字，你永远返回的都是同样的`Class`对象。</li><li>如果类加载器<i>L<sub>1</sub></i>把类*C*的加载委派给了另一个加载器<i>L<sub>2</sub></i>，那么对于任意类型*T*，如果它是*C*的直接父类或父接口类型，或者是*C*中某个字段的类型，或者是*C*中某个方法或构造器的形参的类型，或者是*C*中某个方法的返回类型，<i>L<sub>1</sub></i>和<i>L<sub>2</sub></i>要返回相同的`Class`对象。</li><li>如果一个用户自定义的类加载器对类和接口的二进制表达做了预提取，或者一趟加载了一组相关的类，如果出现加载错误，必须在这些类或接口原本没有发生预提取的情况下在程序中可能出错的点上反馈出来。</li></ul></sub>

创建过后，一个类或接口就不能只靠名字来判断了，而是需要一对儿：名字（§4.2.1）和定义加载器。每个这样的类或接口只属于一个*运行时包*。一个类或接口的运行时包要靠包名以及该类或接口的定义加载器来决定。

### 5.3.1 使用Bootstrap类加载器

使用引导类加载器加载并创建*N*所代表的类或接口*C*的过程如下。

首先，JVM要判断引导类加载器是否已经被记录成*N*代表的类或接口的启动加载器。如果是，那么这个类或接口就是*C*，不需要做类的加载和创建了。

否则，JVM把*N*作为一个参数，调用引导类加载器的一个方法。要加载*C*，引导类加载器通过一种平台相关的方式定位到一个可能的*C*的表达，然后请求JVM用引导类加载器从这个可能的表达中搞出一个*N*所代表的类或接口*C*，然后创建*C*，这里面离不开算法§5.3.5。

&emsp;&emsp;<sub>一般来说，一个类或接口都是放在一种层级化的文件系统中的一个文件中，类或接口的名字也会被编码到文件路径名中，辅助定位。</sub>

如果找到了一个*C*的可能的表达，但是从表达中往出搞*C*的时候失败了，那么*C*的加载和创建过程也因此而失败。

否则，*C*的加载和创建就算是成功了。

### 5.3.2 使用用户定义的类加载器

使用用户定义的类加载器*L*来加载和创建*N*代表的非数组类或接口*C*的过程如下。

首先，JVM要判断*L*是不是已经被记录成*N*代表的类或接口的启动加载器了。如果是，那么这个类或接口就是*C*，不需要做类的加载和创建了。

否则，JVM调用*L*上的`ClassLoader`类的`loadClass`方法，把类或接口的名字*N*传进去。要完成类或接口*C*的创建和加载，*L*必须要执行以下两种操作之一：

1. 类加载器*L*可以直接加载*C*。这要拿到一个字节数组，它可能能够把*C*表达成一个`ClassFile`结构体（§4.1），然后调用`ClassLoader`类的`defineClass`方法。调用这个方法可以让JVM用*L*从字节数组中搞出一个*N*代表的类或接口*C*，并创建*C*，也要用到算法§5.3.5。*L*要把`defineClass`的结果作为`loadClass`的结果。
2. 类加载器*L*可以间接加载*C*，这是把*C*的加载委派给另外的类加载器*L'*。这个过程是要把参数*N*传给*L'*的一个方法（一般是`ClassLoader`类的`loadClass`方法）。*L*要把该方法的结果作为`loadClass`的结果。

不管用哪种方法都要遵守下面的规则：

- 如果一个类加载器无法找到*N*代表的类或接口的一个可能的表达，那么必须抛出一个`ClassNotFoundException`。*C*的加载和创建过程进而失败，报出一个由`ClassNotFoundException`导致的`NoClassDefFoundError`。
- 如果一个类加载找到了*C*的一个可能的表达，但是从里面往出搞*C*的时候失败了，那么*C*的加载和创建过程就以同样的原因失败。
- 如果一个类加载器抛出了一个非`ClassNotFoundException`的异常，那么*C*的加载和创建过程就以同样的原因失败。

如果调用*L*的`loadClass`得到了一个结果，那么：

- 如果结果是`null`，或者是一个名字不叫*N*的类或接口，那么就要丢弃该结果，加载和创建过程以`NoClassDefFoundError`失败告终。
- 否则，结果是创建好的类或接口*C*。JVM把*L*记录为*C*的启动加载器（§5.3.4）。*C*的加载和创建成功了。

&emsp;&emsp;&emsp;&emsp;<sub>从JDK1.1开始，Oracle的JVM让类加载器加载类或接口的时候，会调用单个参数的`loadClass`方法。参数就是要加载的类或接口的名字。还有一个俩参数的`loadClass`方法，第二个参数是一个`boolean`，表示是否要链接这个类或接口。JDK1.0.2中只有俩参的版本，因为Oracle的JVM实现要依赖它来链接被加载的类或接口。从JDK1.1开始，Oracle的JVM实现直接链接类或接口，不再依赖类加载器。</sub>

### 5.3.3 创建数组类

下面的步骤是通过类加载器*L*创建名为*N*的数组类*C*。*L*可能是一个引导类加载器或者是一个用户自定义的类加载器。

首先，JVM要判断*L*是否已经被记录为某个数组类的启动加载器了，而且这个数组类的元素类型就是*N*。如果是，那么它就是类*C*，不需要创建数组类了。

否则，执行下面的步骤来创建*C*：

1. 如果元素类型是一个`reference`类型，那么就对*L*递归式的应用本节介绍的算法（§5.3）来加载并创建*C*的元素类型。
2. JVM创建一个新的数组类，采用指定的元素类型以及维度。

&emsp;&emsp;&nbsp;&nbsp;&nbsp;如果元素类型是一个`reference`类型，那么JVM就把元素类型的定义加载器标记为*C*的定义加载器。否则，JVM就把引导类加载器标记为*C*的定义加载器。

&emsp;&emsp;&nbsp;&nbsp;&nbsp;否则，JVM就将*L*记录为*C*的启动加载器（§5.3.4）。

&emsp;&emsp;&nbsp;&nbsp;&nbsp;如果元素类型是一个`reference`类型，那么数组类的可访问性就有元素类型的可访问性决定（§5.4.4）。否则该数组类就可以被所有的类和接口访问。

### 5.3.4 加载约束

使用类加载器时要保证类型安全的链接是需要特殊注意的。可能存在不同的类加载器都在对*N*代表的类或接口启动加载，而且*N*在不同的加载器中可能代表不同的类或接口。

当一个类或接口<code><i>C</i> = &lt;<i>N<sub>1</sub></i>, <i>L<sub>1</sub></i>&gt;</code>符号引用了另一个类或接口<code><i>D</i> = &lt;<i>N<sub>2</sub></i>, <i>L<sub>2</sub></i>&gt;</code>的字段或方法，符号引用包含了声明字段类型或方法返回类型和参数类型的描述符。必须要保证字段或方法描述符中的任意类型名*N*被<i>L<sub>1</sub></i>和<i>L<sub>2</sub></i>加载时都代表同样的类或接口。

要保证这一点，JVM在准备（§5.4.2）和解析（§5.4.3）阶段搞了<code><i>N<sup>L<sub>1</sub></sup></i> = <i>N<sup>L<sub>2</sub></sup></i></code>这种形式的*加载约束*。为了强制满足该约束，JVM会在某些规定的时刻（见§5.3.1、§5.3.2、§5.3.3、§5.3.5），将特定的加载器记录为特定类的启动加载器。记录之后，JVM必须立刻检查有没有违反加载约束的地方。如果有，就撤回记录，然后JVM报一个`LinkageError`，加载过程继而失败。

同样，应用一条加载约束（见§5.4.2、§5.4.3.2、§5.4.3.3、§5.4.3.4）后JVM必须立刻检查看看是否存在违规的情况。如果有，新应用的加载约束就要撤回，然后JVM报一个`LinkageError`，过程继而失败（可能是在解析或准备阶段）。

JVM只会在我们提到的这些场景中检查是否存在加载约束被违反的情况。一个加载约束被违反，当且仅当以下四个条件全部成立：

- 存在一个加载器*L*，*L*已经被JVM记录为名为*N*的类*C*的启动加载器。
- 存在一个加载器*L'*，*L'*已经被JVM记录为名为*N*的类*C'*的启动加载器。
- 约束集合（的传递闭包）定义的等价关系为<code><i>N<sup>L</sup></i> = <i>N<sup>L'</sup></i></code>。
- <code><i>C</i> ≠ <i>C'</i></code>。

&emsp;&emsp;&emsp;&emsp;<sub>关于类加载器和类型安全的完备知识体系已经超出了本规范的范围。要想了解更加详细的知识，读者们可以去看Sheng Liang和Gilad Bracha的*JVM的动态类加载*（*这是1998年ACM SIGPLAN会议中关于面向对象编程系统、语言及应用议程中的一部分*）。</sub>

### 5.3.5 从class文件表达搞类

下面的步骤是用类加载器*L*从一个可能的`class`文件格式表达中搞出一个名为*N*的非数组类或接口*C*。

1. 首先，JVM要判断*L*是否已经被记录为*N*代表的类或接口的启动加载器。如果是，那么这次暗夜行动就是无效的，报出一个`LinkageError`。
2. 否则，JVM要尝试解析这个可能的表达。这个可能的表达可能实际上并不是*C*的一个有效表达，因此必须检查以下问题：
    - 如果这份可能的表达不是一个`ClassFile`结构体（§4.1，§4.8），那么就抛一个`ClassFormatError`。
    - 否则，如果这份可能的表达不属于受支持的大版本或小版本（§4.1），那么就抛一个`UnsupportedClassVersionError`。<br/><br/><sub>`UnsupportedClassVersionError`是`ClassFormatError`的一个子类，从JDK1.2引入的，为了可以方便的标识出尝试加载一个类但它的表达并不是受支持的`class`文件格式版本时导致的`ClassFormatError`。在JDK1.1以及这之前，如果版本不支持，就抛一个`NoClassDefFoundError`或`ClassFormatError`，取决于类是被系统类加载器还是用户自定义类加载器加载的。</sub><br/><br/>
    - 否则，如果这份可能的表达并不是名为*N*的类或接口，那就抛一个`NoClassDefFoundError`。<br/><br/>当这份可能的表达包含的`this_item`属性中声明的名字不是*N*，或者它的`access_flags`属性设置了`ACC_MODULE`标记时，就会出现上面说的情况。
3. 如果*C*有一个直接父类，那么从*C*到它的直接父类的符号引用的解析使用§5.4.3.1中的算法。注意如果*C*是一个接口，那么它的直接父类必须是`Object`，而且必须得是已经完成加载了的。只有`Object`不存在直接父类。<br/><br/>类或接口解析失败时抛出的异常都可以在往出搞类的时候抛出来。而且，搞的时候必须要检查以下问题：
    - 如果*C*的任意父类是*C*本身，那就要抛一个`ClassCircularityError`。
    - 否则，如果*C*的直接父类实际上是一个接口或`final`类，那就抛一个`IncompatibleClassChangeError`。
    - 否则，如果*C*的直接父类有`PermittedSubclasses`属性（§4.7.31），而且满足以下任意条件，就要抛一个`IncompatibleClassChangeError`：
        - 这个父类跟*C*不在同一个运行时包中（§5.3.6）。
        - *C*不带`ACC_PUBLIC`标记（§4.1），并且这个父类跟*C*不在同一个运行时包中（§5.3）。
        - 这个父类的`PermittedSubclasses`属性的`classes`数组中不存在引用名为*N*的类或接口的记录。
    - 否则，如果*C*是一个类，并且*C*中声明的某个实例方法会覆盖（§5.4.5）它父类中的一个`final`实例方法，那么要抛`IncompatibleClassChangeError`。
4. 如果*C*存在直接父接口，那么从*C*到它的直接父接口的符号引用的解析使用§5.4.3.1中的算法。<br/><br/>类或接口解析失败时抛出的异常都可以在往出搞类的时候抛出来。而且，搞的时候必须要检查以下问题：
    - 如果*C*的任意父接口是*C*本身，那就要抛一个`ClassCircularityError`。
    - 否则，如果*C*的直接父接口实际上并不是一个接口，那就抛一个`IncompatibleClassChangeError`。
    - 否则，对于任意*C*的直接父接口，如果*C*的直接父接口有`PermittedSubclasses`属性（§4.7.31），而且满足以下任意条件，就要抛一个`IncompatibleClassChangeError`：
        - 这个父接口跟*C*不在同一个运行时包中（§5.3.6）。
        - *C*不带`ACC_PUBLIC`标记（§4.1），并且这个父接口跟*C*不在同一个运行时包中。
        - 这个父接口的`PermittedSubclasses`属性的`classes`数组中不存在引用名为*N*的类或接口的记录。

如果以上1-4步骤中没有发生异常，那么类或接口*C*就搞成功了。JVM把*C*的定义加载器标记为*L*，把*L*记录成*C*的一个启动加载器（§5.3.4），并在方法区（§2.5.4）中创建*C*。

&emsp;&emsp;<sub>一旦搞成功了，必须要等到参与*C*加载过程（直接或间接）的所有类加载器都返回了结果*C*，这样*C*的加载和创建才算是完成了。根据用户自定义的类加载器干的那些事儿来看，*C*的加载和创建过程还是有可能会失败的（§5.3.2）。</sub>

如果1-4步骤中抛出了异常，那么类或接口*C*的暗夜行动就以该异常而失败。

### 5.3.6 模块与分层

JVM支持将类和接口组织成模块。类或接口*C*在模块*M*中的身份可以用来控制从其它模块的类和接口对*C*的访问（§5.4.4）。

模块身份要用运行时包（§5.3）来定义。程序要判断出每个模块中的包的名字，以及创建这些包中的类和接口的类加载器；然后拿着这些包和类加载器去调用`ModuleLayer`类的`defineModule`方法。调用该方法可以让JVM创建一个新的*运行时模块*，它关联了类加载器的运行时包。

每个运行时模块都给出了它*导出*的运行时包，这会影响对这些运行时包中的`public`类和接口的访问。每个运行时模块还给出了它*读取*的其它运行时模块，这会影响它内部的代码对这些运行时模块中`public`类型和接口的访问。

我们说*一个类在一个运行时模块中*，当且仅当该类的运行时包关联了（如果该类真正被创建了，那就是将要关联）这个运行时模块。

一个类只会被一个类加载器创建到一个运行时包中，也就是只有一个运行时模块，因为JVM不支持一个运行时包关联（更形象的说应该是“分散在”）多个运行时模块。

一个运行时模块只会隐式的绑定到一个类加载器，这是由`defineModules`的语义决定的。另一方面，一个类加载器可以创建出不同运行时模块中的类，因为JVM不要求一个类加载器的所有运行时包都要关联到同样的运行时模块上。

&emsp;&emsp;<sub>换句话说，类加载器和运行时模块不需要是1:1的。对于一组要加载的模块，如果程序能够判断出每个模块中的包名仅出现在该模块中，那么程序就可以只定义一个类加载器来调用`defineModules`。这个类加载器可以在多个运行时模块中创建类。</sub>

每个由`defineModules`创建的运行时模块都属于一个*层*。一层就代表了一组类加载器，它们共同创建了一组运行时模块中的类。一共有两种层：JVM提供的引导层，以及用户自定义层。引导层在JVM启动的时候以实现特定的方式创建。它把标准运行时模块`java.base`和引导类加载器定义的标准运行时包关联了起来，比如`java.lang`。用户自定义的层由程序来创建，可以创建出多组运行时模块，它们都依赖了`java.base`以及其它的标准运行时模块。

一个运行时模块只会隐式的包含于一个层中，这是由`defineModules`的语义决定的。但是，一个类加载器可能会创建出不同层中运行时模块中的类，因为同一个类加载器可能要多次调用`defineModules`。访问控制是由类的运行时模块来决定的，而不是创建它的类加载器或是类加载器服务的层（们）。

类加载器都定义在一个层中，运行时模块也都是一个层的组成部分，在层创建之后，这些都是不可变的。但是`ModuleLayer`类为程序提供了一定程度的动态控制，可以控制一个用户自定义层中运行时模块之间的关系。

如果一个用户自定义的层包含了多个类加载器，那么创建该层的程序就要负责这些类加载器之间的委派。JVM不会检查层内类加载器之间的委派是否跟层内运行时模块之间的访问一致。而且，如果为了获取其他的运行时模块，一个层的运行时模块被`ModuleLayer`类修改了，那么JVM也不会去检查层中的类加载器是否被某种旁门左道的机制调整过，让委派也形成一致。

&emsp;&emsp;<sub>类加载器和层之间有类似的地方也有不一样的地方。另一方面，一个层跟一个类加载器的相似之处包括它们都可以委派给多个在它们之前创建模块或类的父层或类加载器。如此说来，一个层中定义的模块可能会依赖于不属于该层的模块，它们是在这之前定义在一个或多个父层中的模块。再另一方面，一个层只能用来创建一次新模块，而一个类加载器可以通过多次调用`defineClass`随时创建新的类或接口。</sub>

类加载器可以定义与它所在层任何运行时模块都无关的一个运行时包中的类或接口。如果运行时包不是用`defineModules`定义的就会出现这种情况，或者是一个具有简单二进制名（§4.2.1）的类或接口属于一个未命名运行时包（JLS §7.4.2），也会出现这种情况。不管是哪种场景，这种类或接口都被看作是一个特殊的运行时模块中的成员，隐式绑定到了该类加载器上。这种特殊的运行时模块就叫做该类加载器的*未命名模块*。这种类或接口的运行时包关联了这个类加载器的未命名模块。对于未命名模块有一些特殊的规则，用来最大化它们跟其它运行时包之间的互操作性，具体如下：

- 一个类加载器的未命名模块不同于绑定到该类加载的所有其它的运行时模块。
- 一个类加载器的未命名模块不同于绑定到其它类加载器的所有运行时模块（包括未命名模块）。
- 每个未命名模块都可以读取每一个运行时模块。
- 每个未命名模块都把它所有的运行时包导出给每一个运行时模块。

## 5.4 链接

对一个类或接口进行链接，就是要按需校验和准备这个类或接口，以及它的直接父类、直接父接口、元素类型（如果是数组类型）。链接还要解析类或接口中的符号引用，尽管不用跟类或接口的校验和准备同时进行。

本规范允许具体实现灵活地选择链接（以及由于递归导致的加载）的时机，这是由于保证了以下几点要素：

- 类或接口在链接前完全加载好。
- 类或接口在初始化前完全校验和准备好。
- 链接期间发生的错误会在程序中报出来，啥时候报咧，当程序执行某个操作直接或间接的需要链接报错的类或接口时，错误就报出来了。
- 动态计算常量的符号引用不会进行解析，直到（i）执行了一个引用它的*ldc*、*ldc_w*、*ldc2_w*指令，或（ii）将它作为静态参数的某个引导方法被调用了。<br/><br/>动态计算调用点的符号引用不会进行解析，知道将它作为静态参数的某个引导方法被调用了。

比如，JVM的实现可以选择“懒”链接策略，类或接口中的符号引用（除了上面说的符号引用）只在用到的时候单独解析。或者也可以选择“饥渴的”链接策略，类或接口在校验时一次性把所有符号引用都解析了。这就是说在某些实现中，类或接口初始化之后有可能解析过程还能继续。不管走哪种策略，解析过程中发现的错误必须要在程序中的某一点上，（直接或间接）使用类或接口的符号引用时报出来。

由于链接的时候要分配新的数据结构，所以它也可能因为`OutOfMemoryError`而失败。

### 5.4.1 校验

*校验*（§4.10）可以保证类或接口的二进制表达是格式正确的（§4.9）。校验的时候可能会把其它的类加载（§5.3）进来，但是不会校验或准备它们。

如果类或接口的二进制表达无法满足§4.9列出的静态或结构化约束，那么在程序中导致该类或接口被校验的某处必须要抛出一个`VerifyError`。

如果JVM尝试校验一个类或接口时因为`LinkageError`（或子类）实例错误失败，那么后续对这个类或接口的校验总是会跟最初的尝试一样，以同样的错误失败。

### 5.4.2 准备

*准备*就是要创建类或接口的静态字段并把它们初始化到对应的默认值（§2.3，§2.4）。这个事儿不需要执行任何JVM代码；静态字段的显式初始化器作为初始化（§5.5）的一部分来进行，不在准备阶段。

在类或接口*C*的准备阶段，JVM暗含以下加载约束（§5.3.4）：

1. 假设<code><i>L<sub>i</sub></i></code>是*C*的定义加载器。对于*C*中声明的每一个可以覆盖（§5.4.5）父类或父接口<code><i>&lt;D, L<sub>2</sub>&gt;</i></code>中的实例方法<code><i>m</i></code>，JVM暗含以下加载约束。<br/><br/>假设<code><i>m</i></code>的返回类型为<code><i>T<sub>r</sub></i></code>，且<code><i>m</i></code>的形参类型为<code><i>T<sub>f1</sub>, ..., T<sub>fn</sub></i></code>：<br/><br/>如果<code><i>T<sub>r</sub></i></code>不是数组类型，那么<code><i>T<sub>0</sub></i></code>就是<code><i>T<sub>r</sub></i></code>；否则，<code><i>T<sub>0</sub></i></code>就是<code><i>T<sub>r</sub></i></code>的元素类型。<br/><br/>对于*i*=1到*n*：如果<code><i>T<sub>fi</sub></i></code>不是数组类型，那么<code><i>T<sub>i</sub></i></code>就是<code><i>T<sub>fi</sub></i></code>；否则，<code><i>T<sub>i</sub></i></code>就是<code><i>T<sub>fi</sub></i></code>的元素类型。<br/><br/>对于*i*=0到*n*，<code><i>T<sub>i</sub></i><sup>L<sub>1</sub></sup> = <i>T<sub>i</sub></i><sup>L<sub>2</sub></sup></code>。
2. 对于*C*的父类<code><i>&lt;I, L<sub>3</sub>&gt;</i></code>中声明的每个实例方法<code><i>m</i></code>，如果*C*中没有声明可以覆盖<code><i>m</i></code>的实例方法，那么就要参考*C*和<code><i>&lt;I, L<sub>3</sub>&gt;</i></code>中的方法<code><i>m</i></code>来进行方法选择。假设<code><i>&lt;D, L<sub>2</sub>&gt;</i></code>就是被选中方法的类或接口。那么JVM暗含以下加载约束。<br/><br/>假设<code><i>m</i></code>的返回类型为<code><i>T<sub>r</sub></i></code>，且<code><i>m</i></code>的形参类型为<code><i>T<sub>f1</sub>, ..., T<sub>fn</sub></i></code>：<br/><br/>如果<code><i>T<sub>r</sub></i></code>不是数组类型，那么<code><i>T<sub>0</sub></i></code>就是<code><i>T<sub>r</sub></i></code>；否则，<code><i>T<sub>0</sub></i></code>就是<code><i>T<sub>r</sub></i></code>的元素类型。<br/><br/>对于*i*=1到*n*：如果<code><i>T<sub>fi</sub></i></code>不是数组类型，那么<code><i>T<sub>i</sub></i></code>就是<code><i>T<sub>fi</sub></i></code>；否则，<code><i>T<sub>i</sub></i></code>就是<code><i>T<sub>fi</sub></i></code>的元素类型。<br/><br/>对于*i*=0到*n*，<code><i>T<sub>i</sub></i><sup>L<sub>2</sub></sup> = <i>T<sub>i</sub></i><sup>L<sub>3</sub></sup></code>。

准备阶段可能发生在创建之后的任意时间，但是必须要在初始化之前完成。

### 5.4.3 解析

许多JVM指令——*anewarray, checkcast, getfield, getstatic, instanceof, invokedynamic, invokeinterface, invokespecial, invokestatic, invokevirtual, ldc, ldc_w, ldc2_w, multianewarray, new, putfield, putstatic*——依赖运行时常量池中的符号引用。这些指令的执行都需要*解析*符号引用。

解析过程就是要动态的判断出运行时常量池中的一个符号引用的一个或多个具体的值。在开始时，运行时常量池中的符号引用都是未解析的。

对于（i）类或接口，（ii）字段，（iii）方法，（iv）方法类型，（v）方法句柄，（vi）动态计算常量，指向它们的一个未解析的符号引用，解析过程要遵守§5.4.3.1到§5.4.3.5中给出的规则。在前三小节中，出现符号引用的运行时常量池所在的类或接口标为*D*。然后：

- 如果符号引用解析过程中没有报错，那么解析成功。<br/><br/>后面如果再尝试对这个符号引用进行解析那么就直接成功，直接返回跟首次解析一样的结果实体。如果符号引用的是一个动态计算常量，那就不会为后续的尝试执行引导方法。
- 如果符号引用解析过程中出错了，那么它要么是（i）一个`IncompatibleClassChangeError`（或子类）的一个实例；（ii）解析锅调用某个引导方法时产生的一个`Error`（或子类）的一个实例；（iii）由于类加载失败或违反加载器约束而产生的一个`LinkageError`（或子类）的一个实例。这个错误必须在程序中（直接或间接）使用符号引用的某一点上报出来。<br/><br/>后续再对这个符号引用进行解析的话就直接失败，报的错跟首次尝试解析时抛出的一样。如果符号引用的是一个动态计算常量，那就不会为后续的尝试执行引导方法。<br/><br/>&emsp;&emsp;<sub>由于在一开始尝试解析过程中报的错误再后续尝试中重复抛出，所以当一个模块中的一个类尝试通过它运行时常量池中的符号引用访问另一个模块中的一个未导出的`public`类型时总是会得到同样的错误，告诉你那是一个不可访问的类型（§5.4.4），*即便在该类的首次尝试之后的某一时刻会使用JavaSE平台API来动态的导出该`public`类型所在的包*。</sub>

对于动态计算调用点的未解析符号引用的解析过程要符合§5.4.3.6中的规则。然后：

- 如果符号引用解析过程没有报错，那么解析成功*仅限于`class`文件中需要解析的指令*。这个指令必须要有一个*invokedynamic*操作码。<br/><br/>*在该`class`文件中的这条指令*后续对该符号引用的机械系直接成功，直接返回跟首次解析一样的结果实体。不会为后续的尝试执行引导方法。<br/><br/>对于该`class`文件中的所有其它指令的所有操作码，该符号引用仍旧是未解析的，它在运行时常量池中代表的记录跟上面的*invokedynamic*指令的一样。（最后这句没太明白。）
- 如果符号引用解析过程报错，那么它（i）是一个`IncompatibleClassChangeError`（或子类）的实例；（ii）解析或调用引导方法导致的`Error`（或子类）的实例；（iii）类加载失败或违反加载器约束导致的`LinkageError`（或子类）的实例。这个错误必须在程序中（直接或间接）使用符号引用的某一点上报出来。<br/><br/>*该`class`文件中的同一指令*后续再对这个符号引用解析的话，都跟首次尝试解析的结果一样报错失败。不会为这些后续解析重复执行引导方法。<br/><br/>对于`class`文件中的其他所有指令和操作码来说该符号引用仍旧是未解析的，它在运行时常量池中代表的记录跟上面的*invokedynamic*指令的一样。

上面提到的指令中，有的在符号引用解析时需要额外的链接检查。比如，为了让*getfield*指令能够成功的对它操作的符号引用字段进行解析，它必须要完成§5.4.3.2中的解析步骤，还要检查该字段，不能是`statci`的。如果是`static`，必须报出链接异常。

检查导致的链接异常仅限于某些特殊的JVM指令在描述中提到的范围，并不属于一般性的解析过程。注意，尽管这些异常讲的时候说是因为JVM指令执行而非解析导致的，但仍然可以认为它们会导致解析失败。

#### 5.4.3.1 类和接口解析

要解析*D*中的一个对*N*代表的类或接口*C*的未解析的符号引用，得这么来：

1. *D*的定义加载器用来加载和创建*N*代表的类或接口。这个类或接口是*C*。这个过程详见§5.3。<br/><br/>*C*加载和创建失败时抛出的任何异常都可以作为类和接口解析失败的结果抛出。
2. 如果*C*是一个数组类，且元素类型为`reference`类型，那么对元素类型的类或接口的符号引用的解析需要递归调用§5.4.3.1中的算法。
3. 最后，为*D*到*C*增加访问控制（§5.4.4）。

如果1和2成功了但是3失败了，*C*仍然是有效且可用的。但是解析还是失败，禁止*D*访问*C*。

#### 5.4.3.2 字段解析

要解析*D*中的一个对类或接口*C*的字段的未解析的符号引用，那么必须先解析该字段引用导致的对*C*的符号引用（§5.4.3.1）。因此类或接口引用解析失败时的异常都可以作为字段解析失败的失败结果抛出。如果对*C*的引用可以成功解析，该字段引用本身的解析失败异常就可以抛出来了。

解析字段引用的时候，字段解析首先要尝试在*C*和它父类中查找被引用字段：

1. 如果*C*声明的某个字段，它的名字和描述符跟该字段引用指定的一样，那么查询成功。这个字段就是字段查询的结果。
2. 否则，字段查询顺着类或接口*C*的直接父接口继续向上找。
3. 否则，如果*C*有一个父类*S*，字段查询递归到*S*。
4. 否则，查询失败。

然后，字段的解析结果判定方式为：

- 如果字段查询失败，字段解析抛出一个`NoSuchFieldError`。
- 否则，查询成功。为*D*访问该查询结果字段增加访问控制（§5.4.4）。然后：
    - 如果访问控制失败，字段解析则因此失败。
    - 否则，访问控制成功。隐含的加载约束如下。<br/><br/>假设被引用字段所在的类或接口为<code><i>&lt;E, L<sub>1</sub>&gt;</i></code>。夹着<code><i>L<sub>2</sub></i></code>是*D*的定义加载器。被引用字段的类型为<code><i>T<sub>f</sub></i></code>：如果<code><i>T<sub>f</sub></i></code>不是数组类型，那么*T*就是<code><i>T<sub>f</sub></i></code>；否则*T*就是<code><i>T<sub>f</sub></i></code>的元素类型。<br/><br/>JVM隐含的加载约束为<code><i>T<sup>L<sub>1</sub></sup> = T<sup>L<sub>2</sub></sup></i></code>。<br/><br/>如果这个隐含的加载约束导致出现了加载约束被违反的情况（§5.3.4）。那么字段解析失败。否则，字段解析成功。

#### 5.4.3.3 方法解析

要解析*D*对类*C*中一个方法的未解析的符号引用，首先要解析该方法引用导致的对*C*的符号引用（§5.4.3.1）。因此，类引用的解析失败异常都可以作为方法解析失败的异常结果抛出。如果对*C*的引用解析成功，和方法引用本身相关的解析异常就可以抛出来了。

解析方法引用的时候：

1. 如果*C*是一个接口，方法引用抛出一个`IncompatibleClassChangeError`。
2. 否则，方法解析尝试在*C*和它的父类中定位到被引用的方法：
    - 对于该方法引用声明的名字，如果*C*中只声明了一个这样的方法，并且该声明是一个泛型方法（§2.9.3），那么方法查询成功。描述符中提到的所有类名都解析好了（§5.4.3.1）。<br/><br/>*被解析的方法是泛型方法*。*C*中的方法声明不需要用方法引用中对应的描述符。
    - 否则，如果在*C*中有一个名字和描述符都跟方法引用指定的一样，那么方法查询成功。
    - 否则，如果*C*有一个父类，对*C*的直接父类递归执行第2步方法解析。
3. 否则，方法解析尝试在类*C*的父接口中定位到被引用的方法：
    - 如果对于方法引用给出的名字和描述符，*C*的*最具体父接口方法（maximally-specific superinterface methods）*仅包含一个没有设置`ACC_ABSTRACT`标记的方法，那么就选这个方法，方法查询成功。
    - 否则，如果*C*的任意父接口中声明的一个方法跟方法引用给出的名字和描述符一致，并且没有设置`ACC_PRIVATE`或`ACC_STATIC`标记，那么就在其中任选一个（哎呀，在哪里任选啊），方法查询成功。
    - 否则，方法查询失败。

对于指定方法名和描述符，类或接口*C*中的*最具体父接口方法*就是满足以下所有条件的任意方法：

- 这个方法声明在*C*（直接或间接）的父接口中。
- 这个方法的名字和描述符跟指定的一致。
- 这个方法没有设置`ACC_PRIVATE`或`ACC_STATIC`标记。
- 如果在接口*I*中声明了一个这样的方法，那么对于指定的名字和描述符，在*I*的子接口中就不存在其它的可以成为*C*的*最具体父接口方法*。

方法解析的结果判定方式如下：

- 如果方法查询失败，方法解析抛出一个`NoSuchMethodError`。
- 否则，方法查询成功。为*D*对方法查询结果得到的方法添加访问控制（§5.4.4）。然后：
    - 如果访问控制失败，则方法解析以同样的原因失败。
    - 否则，访问控制成功。然后又要开始隐含加载约束了：<br/><br/>假设<code><i>&lt;E, L<sub>1</sub>&gt;</i></code>就是被引用方法*m*所在的类或接口。假设<code><i>L<sub>2</sub></i></code>是*D*的定义加载器。设*m*的返回类型为<code><i>T<sub>r</sub></i></code>，*m*的形参类型为<code><i>T<sub>f1</sub>, ..., T<sub>fn</sub></i></code>：<br/><br/>如果<code><i>T<sub>r</sub></i></code>不是数组类型，那么<code><i>T<sub>0</sub></i></code>就是<code><i>T<sub>r</sub></i></code>；否则，<code><i>T<sub>0</sub></i></code>就是<code><i>T<sub>r</sub></i></code>的元素类型。<br/><br/>对于*i*=1到*n*：如果<code><i>T<sub>fi</sub></i></code>不是数组类型，那么<code><i>T<sub>i</sub></i></code>就是<code><i>T<sub>fi</sub></i></code>；否则，<code><i>T<sub>i</sub></i></code>就是<code><i>T<sub>fi</sub></i></code>的元素类型。<br/><br/>对于*i*=0到*n*，JVM暗含加载约束<code><i>T<sub>i</sub></i><sup>L<sub>1</sub></sup> = <i>T<sub>i</sub></i><sup>L<sub>2</sub></sup></code>。<br/><br/>如果暗含这些约束导致出现加载约束被违反的情况（§5.3.4），方法解析失败。否则，方法解析成功。<br/><br/><sub>当解析过程在类的父接口中搜索方法时，最好的结果就是找到一个最具体非`abstract`方法。这个方法是可以被选中的，因此需要为其增加类加载器约束。</sub><br/><br/><sub>否则，结果就是无法判定的。这并不新鲜：*JVM规范*从未明确标出哪个方法被选中了，以及应该如何打破“关联”。在JavaSE8之前，这种差别几乎无法观察到。但从JavaSE8开始，接口方法更加异构化，因此必须要小心这种无法判定行为导致的问题。所以：</sub><br/><br/>
    - <sub>解析过程会忽略`private`和`static`的父接口方法。这跟Java语言是一致的，接口方法无法继承。</sub>
    - <sub>解析后方法掌控的任何行为都不应当依赖于方法是否是`abstract`的。</sub><br/><br/>
    <sub>注意，如果解析得到的是一个`abstract`方法，被引用的类*C*可能非`abstract`。如果要求*C*是`abstract`的会跟父接口方法的无法判定行为产生冲突。因此，解析过程假设被调用对象的运行时类有该方法的具体实现。</sub>

#### 5.4.3.4 接口方法解析

要解析一个从*D*到接口*C*中一个接口方法的未解析的符号引用，就要先解析由接口方法引用给出的*C*的符号引用（§5.4.3.1）。因此任何接口引用的失败异常都可以作为接口方法引用失败的结果抛出。如果*C*的引用可以成功解析，和接口方法引用相关的解析异常就可以抛出来了。

解析接口方法引用时：

1. 如果*C*不是接口，接口方法解析要抛`IncompatibleClassChangeError`。
2. 否则，如果*C*声明了一个方法，它的名字和描述符跟接口方法引用给出的一致，方法查询成功。
3. 否则，如果类`Object`声明了一个方法，它的名字和描述符跟接口方法引用给出的一致，而且它设置了`ACC_PUBLIC`标记，而且没设置`ACC_STATIC`标记，方法查询成功。
4. 否则，如果方法引用给出的名字和描述符对应的*C*的最具体父接口方法（§5.4.3.3）仅包含一个方法，而且它没有设置`ACC_ABSTRACT`标记，那么该方法被选中，方法查询成功。
5. 否则，如果*C*的任意父接口声明了一个方法，它的名字和描述符跟方法引用给出的一致，并且没有设置`ACC_PRIVATE`和`ACC_STATIC`标记，那么在这其中任选一个方法，方法查询成功。
6. 否则，方法查询失败。

接口方法解析的结果判定方式如下：

- 如果方法查询失败，接口方法解析抛出一个`NoSuchMethodError`。
- 否则，方法查询成功。为从*D*到方法查询结果得到的方法之间的访问增加访问控制。然后：
    - 如果访问控制失败，接口方法解析以同样的原因失败。
    - 否则，访问控制成功。暗含以下加载约束。<br/><br/>假设<code><i>&lt;E, L<sub>1</sub>&gt;</i></code>就是被引用的接口方法*m*所在的类或接口。假设<code><i>L<sub>2</sub></i></code>是*D*的定义加载器。设*m*的返回类型为<code><i>T<sub>r</sub></i></code>，*m*的形参类型为<code><i>T<sub>f1</sub>, ..., T<sub>fn</sub></i></code>：<br/><br/>如果<code><i>T<sub>r</sub></i></code>不是数组类型，那么<code><i>T<sub>0</sub></i></code>就是<code><i>T<sub>r</sub></i></code>；否则，<code><i>T<sub>0</sub></i></code>就是<code><i>T<sub>r</sub></i></code>的元素类型。<br/><br/>对于*i*=1到*n*：如果<code><i>T<sub>fi</sub></i></code>不是数组类型，那么<code><i>T<sub>i</sub></i></code>就是<code><i>T<sub>fi</sub></i></code>；否则，<code><i>T<sub>i</sub></i></code>就是<code><i>T<sub>fi</sub></i></code>的元素类型。<br/><br/>对于*i*=0到*n*，JVM暗含加载约束<code><i>T<sub>i</sub></i><sup>L<sub>1</sub></sup> = <i>T<sub>i</sub></i><sup>L<sub>2</sub></sup></code>。<br/><br/>如果暗含这些约束导致出现加载约束被违反的情况（§5.3.4），接口方法解析失败。否则，接口方法解析成功。<br/><br/><sub>访问控制是必需的，因为接口方法解析可能会选择接口*C*中的一个`private`方法。（在JavaSE8之前，接口方法解析的结果可能会是`Object`类的一个非`public`方法，或者是`Object`类的一个`static`方法；这种结果不符合Java语言的继承模型，而且从JavaSE8开始也不允许了。）</sub>

#### 5.4.3.5 方法类型与方法句柄解析

要解析一个对方法类型的未解析的符号引用，跟类和接口的未解析符号引用差不多（§5.4.3.1），名字要跟方法描述符中给出的类型一致（§4.3.3）。

类引用解析报错时的任何异常都可以在方法类型解析中报出来。

成功的方法类型解析的结果是一个`reference`，指向一个`java.lang.invoke.MethodType`的实例，表示一个方法描述符。

<sub>不管运行时常量池中是否真的包含了对方法描述符中给出的类和接口的符号引用，都要进行方法类型解析。而且，解析被认为是发生在*未解析*的符号引用上，因此，如果后面能加载到合适的类和接口，一个方法类型解析失败不会导致后面对相同方法描述符文本的方法类型的解析也失败。</sub>

对于一个方法句柄的未解析符号引用的解析则更加复杂。JVM解析的每一个方法句柄都有一个等价的指令序列，称为它的*字节码行为*，由方法句柄的*种类*所决定。方法句柄的九个种类的整数值以及描述都列在了表5.4.3.5-A中。

指令序列对字段或方法的符号引用写作`C.x:T`，`x`和`T`表示字段或方法的名字和描述符（§4.3.2，§4.3.3），`C`则是字段或方法所在的类或接口。

**表5.4.3.5-A 方法句柄的字节码行为**

|**种类**|**描述**|**解释**
|-|-|-
|1|`REF_getField`|`getfield C.f:T`
|2|`REF_getStatic`|`getstatic C.f:T`
|3|`REF_putField`|`putfield C.f:T`
|4|`REF_putStatic`|`putstatic C.f:T`
|5|`REF_invokeVirtual`|`invokevirtual C.m:(A*)T`
|6|`REF_invokeStatic`|`invokestatic C.m:(A*)T`
|7|`REF_invokeSpecial`|`invokespecial C.m:(A*)T`
|8|`REF_newInvokeSpecial`|`new C; dup; invokespecial C.<init>:(A*)V`
|9|`REF_invokeInterface`|`invokeinterface C.m:(A*)T`

假设*MH*是要解析的方法句柄（§5.1）的符号引用。而且：

- 假设*R*是包含在*MH*中对字段或方法的符号引用。<br/><br/>*R*继承自`CONSTANT_Fieldref`、`CONSTANT_Methodref`或`CONSTANT_InterfaceMethodref`结构体，*R*被*MH*所继承的`CONSTANT_MethodHandle`的`reference_index`属性所引用。<br/><br/><sub>例如，*R*是一个*C.f*的符号引用，它的字节码行为分类为1，而一个对<i>C.&lt;init&gt;</i>的符号引用的字节码行为分类为8。</sub><br/><br/>如果*MH*的字节码行为分类为7（`REF_invokeSpecial`），那么*C*必须是当前类或接口，或者是当前类的父类，或者是当前类或接口的直接父接口，或者是`Object`。
- 假设*T*是*R*引用的字段的类型，或者是*R*引用的方法的返回类型。设<i>A<sup>\*</sup></i>为*R*引用的方法的参数类型序列（可能为空）。<br/><br/>*T*和<i>A<sup>\*</sup></i>继承自`CONSTANT_NameAndType`结构体，它被*R*所继承的`CONSTANT_Fieldref`、`CONSTANT_Methodref`或`CONSTANT_InterfaceMethodref`结构体的`name_and_type_index`属性所引用。

要解析*MH*，*MH*字节码行为中的所有类、接口、字段、方法的符号引用都要被解析，得这么来：

1. 解析*R*。当*MH*字节码行为分类为1、2、3、4时就是字段解析（§5.4.3.2），当*MH*的字节码行为分类为5、6、7、8时就是方法解析（§5.4.3.3），当*MH*字节码行为分类为9时就是接口方法解析（§5.4.3.4）。
2. 对*R*的解析结果添加以下约束。这些约束条件跟指令序列校验和执行时对相关字节码行为强制要求的约束条件是对应的。
    - 如果*MH*字节码行为分类是8（`REF_newInvokeSpecial`），那么*R*必须解析成类*C*中声明的一个实例初始化方法。
    - 如果*R*被解析成了一个`protected`成员，那么根据*MH*的字节码行为，采取以下规则：
        - 对于分类1、3、5（`REF_getField`、`REF_putField`、`REF_invokeVirtual`）：如果`C.f`或`C.m`被解析成了一个`protected`字段或方法，且*C*跟当前类不在同一个运行时包中，那么*C*必须可以被赋值给当前类。
        - 对于分类8（`REF_newInvokeSpecial`）：如果<i>C.&lt;init&gt;</i>被解析成了一个`protected`方法，那么*C*必须跟当前类声明在同一个运行时包中。
    - 根据*MH*的字节码行为分类，*R*必须被解析成一个`static`或非`static`成员：
        - 对于分类1、3、5、7、9（`REF_getField`、`REF_putField`、`REF_invokeVirtual`、`REF_invokeSpecial`、`REF_invokeInterface`）：`C.f`或`C.m`必须被解析成一个非`static`字段或方法。
        - 对于分类2、4、6（`REF_getStatic`、`REF_putStaticS`、`REF_invokeStatic`）：`C.f`或`C.m`必须被解析成一个`static`字段或方法。
3. 解析过程类似对类和接口的未解析符号引用的解析，它们的名字按照顺序对应于<i>A<sup>\*</sup></i>中的每个类型以及类型*T*。
4. 获取`java.lang.invoke.MethodType`实例的一个引用类似解析一个方法类型的未解析符号引用一样，而这个方法类型包含的方法描述符按*MH*类型分类列在了表5.4.3.5-B中。<br/><br/><sub>就好像是一个方法句柄的符号引用包含了一个解析后终将得到的方法类型的符号引用。所得方法类型的详细结构见表5.4.3.5-B。</sub>

**表5.4.3.5-B 方法句柄的方法描述符**

|**种类**|**描述**|**解释**
|-|-|-
|1|`REF_getField`|`(C)T`
|2|`REF_getStatic`|`()T`
|3|`REF_putField`|`(C,T)V`
|4|`REF_putStatic`|`(T)V`
|5|`REF_invokeVirtual`|`(C,A*)T`
|6|`REF_invokeStatic`|`(A*)T`
|7|`REF_invokeSpecial`|`(C,A*)T`
|8|`REF_newInvokeSpecial`|`(A*)C`
|9|`REF_invokeInterface`|`(C,A*)T`

在第1、3、4步中，类、接口、字段或方法符号引用解析失败时的任何异常都可以作为方法句柄解析失败的异常结果抛出。在第2步中，特定约束导致失败时，方法句柄解析都会因`IllegalAccessError`而失败。

&emsp;&emsp;<sub>这么做的目的是让方法句柄的解析跟JVM成功校验和解析字节码行为符号引用所处的环境完全一样。特别是，`private`、`protected`或`static`成员的方法句柄可以直接在对应的类中创建，这样相应的一般访问也都是合法的。</sub>

方法句柄解析成功得到的是一个`java.lang.invoke.MethodHandle`实例的`reference`，代表方法句柄*MH*。

这个`java.lang.invoke.MethodHandle`实例的类型描述符是在上面方法句柄解析的第三步中得到的`java.lang.invoke.MethodType`实例。

&emsp;&emsp;<sub>这样，类型描述符就是对方法句柄`java.lang.invoke.MethodHandle`的`invokeExact`的一次有效调用，并且跟字节码行为拥有完全一样的整体效果。用一套有效的参数来调用这个方法句柄产生的效果以及返回的结果（如果有），和对应字节码行为完全一样。</sub>

如果方法引用*R*设置了`ACC_VARARGS`标记（§4.6），那么`java.lang.invoke.MethodHandle`实例就是一个变参方法句柄；否则就是固定参数方法句柄。

如果一个变参方法句柄通过`invoke`调用时要做参数列表装箱（JLS §15.12.4.2），那么它的行为符合`invokeExact`，就好像没有设置`ACC_VARARGS`。

如果方法引用*R*设置了`ACC_VARARGS`标记，并且<i>A<sup>\*</sup></i>是空序列或者它的最后一个参数类型非数组类型，那么方法句柄解析就要抛`IncompatibleClassChangeError`。也就是变参方法句柄创建失败了。

不要求JVM实现隐藏方法类型或方法句柄。也就是说，对结构上相同的方法类型或方法句柄的两个不同的符号引用，解析得到的可能并不是一样的`java.lang.invoke.MethodType`或`java.lang.invoke.MethodHandle`实例。

&emsp;&emsp;<sub>JavaSE平台API中的`java.lang.invoke.MethodHandles`类允许创建没有字节码行为的方法句柄。它们的行为由创建它们的`java.lang.invoke.MethodHandles`定义。比如，一个方法句柄可能在被调用时先对参数做变形，然后把变形后的参数用来调用另一个方法句柄，然后对返回结果再做变形，然后再把变形后的值作为自己的返回结果。</sub>

#### 5.4.3.6 动态计算常量和调用点解析

要解析一个动态计算常量或调用点的为解析符号引用*R*，拢共分三步。首先，检查*R*看一下哪些代码要作为它的*引导方法*，以及这些代码需要哪些参数。然后，把参数打包进数组，然后调用引导方法。最后，验证引导方法的结果，作为解析结果。

第一步又包含了以下步骤：

1. *R*提供了一个*引导方法句柄*的符号引用。解析引导方法句柄（§5.4.3.5）得到一个`java.lang.invoke.MethodHandle`实例的`reference`。<br/><br/>方法句柄的符号引用解析的任何失败异常都可以在这个步骤中抛出。<br/><br/>如果*R*是一个动态计算常量的符号引用，那么设*D*为引导方法句柄的类型描述符。（就是说*D*是一个`java.lang.invoke.MethodType`实例的`reference`）*D*给出的第一个参数类型必须是`java.lang.invoke.MethodHandle.Lookup`，否则解析以`BootstrapMethodError`失败告终。出于一些历史原因，动态计算调用点的引导方法句柄的约束不太一样。
2. 如果*R*是一个动态计算常量的符号引用，那么它会给出一个字段描述符。<br/><br/>如果字段描述符代表的是一个基本类型，那么就可以得到一个代表该类型的预定义`Class`对象的`reference`（见`Class`类的`isPrimitive`方法）。<br/><br/>否则，字段描述符代表一个类或接口类型，或者是数组类型。得到一个代表该类型的`Class`对象的`reference`，类似对一个类或接口的未解析符号引用做了解析似的（§5.4.3.1），它的名字跟字段描述符给出的类型名一致。<br/><br/>类或接口符号引用解析过程中的任何失败异常都可以在这个步骤中抛出。
3. 如果*R*是一个动态计算调用点的符号引用，那么它会给出一个方法描述符。<br/><br/>可以得到一个`java.lang.invoke.MethodType`实例的`reference`，类似对一个方法类型的未解析符号引用的解析（§5.4.3.5），参数和返回类型跟方法描述符给出的一样。<br/><br/>方法类型符号引用解析过程中抛出的任何失败异常都可以在这个步骤中抛出。
4. *R*给出了零或多个*静态参数*，可以将应用特定的元数据信息传递给引导方法。每个静态参数*A*按照在*R*中的顺序进行解析，过程如下：
    - 如果*A*是一个字符串常量，那么就得到一个`String`类实例的`reference`。
    - 如果*A*是一个数字常量，那么得到一个`java.lang.invoke.MethodHandle`实例的`reference`，过程如下：
        - 设*v*就是数字常量的值，设*T*为数字常量类型对应的字段描述符。
        - 设*MH*是一个方法句柄，生成方式类似于调用`java.lang.invoke.MethodHandles`的`identity`方法，传入的参数代表`Object`类。
        - 得到一个`java.lang.invoke.MethodHandle`实例的`reference`，类似调用`MH.invoke(v)`，它的方法描述符为`(T)Ljava/lang/Object;`。
    - 如果*A*是一个动态计算常量的符号引用，字段描述符表达的是一个基本类型*T*，那么*A*就解析出来了，得到一个基本类型值*v*。有了*v*和*T*，根据前面说的数值常量的步骤，就可以得到一个`java.lang.invoke.MethodHandle`的`reference`。
    - 如果*A*是其它种类的符号引用，得到的结果就是*A*的解析结果。
&emsp;&emsp;在运行时常量池的符号引用中，动态计算常量的符号引用是特殊的存在，因为它们继承的`constant_pool`记录语法上可以通过`BootstrapMethods`属性（§4.7.23）引用它们自身。但是，JVM不支持对一个依赖其自身的动态计算常量的符号引用进行解析（就是作为静态参数传给自己的引导方法）。因此，当*R*和*A*都是动态计算常量的符号引用时，如果*A*跟*R*一样，或者*A*给出了一个（直接或间接）引用*R*的静态参数，那么在*R*需要被重复解析的地方就会报一个`StackOverflowError`失败。

&emsp;&emsp;<sub>不同于类的初始化（§5.5），未初始化的类之间可以有环，但是解析中不允许动态计算常量的符号引用中有环。如果解析实现时递归使用了一个栈，那自然要出一个`StackOverflowError`。如果没有，实现时就要检查环的存在，而不是说对于动态计算常量就搁那无限循环或返回一个默认值。</sub>

&emsp;&emsp;<sub>如果引导方法中引用了一个正在被解析的动态计算常量的话也可能会出现类似的环。这对*invokedynamic*引导方法来说总是可能出现的，而且在解析的时候不需要特殊对待；递归调用`invokeWithArguments`的话则会出`StackOverflowError`。</sub>

&emsp;&emsp;符号引用解析过程中可以抛出的异常都可以在这个步骤中抛出。

第二步，调用引导方法句柄，包含以下步骤：

1. 分配一个成员类型为`Object`且长度为*n*+3的数组，*n*就是*R*给出的静态参数的数量（*n*≥0）。<br/><br/>数组中第零个元素设置为*R*所在类对应的`java.lang.invoke.MethodHandles.Lookup`实例的一个`reference`，生成方式类似于调用`java.lang.invoke.MethodHandles`的`lookup`方法。<br/><br/>数组的第一个元素设置为*N*代表的`String`实例的一个`reference`，*N*就是*R*给出的一个非限定名。<br/><br/>第二个元素设置为`Class`实例的一个`reference`，或者是之前为*R*的字段描述符或方法描述符拿到的`java.lang.invoke.MethodType`实例的一个`reference`。<br/><br/>数组中后续的元素，如果之前解析过*R*的静态参数，那就设置成得到的`reference`。数组中`reference`的顺序跟*R*中静态参数的顺序一致。<br/><br/>&emsp;&emsp;<sub>JVM实现时可以跳过这种数组的分配，可观察到的行为不会产生任何变化，直接把这些参数传给引导方法。</sub>
2. 调用引导方法句柄，类似调用`BMH.invokeWithArguments(args)`，里面的`BMH`就是引导方法句柄，`args`是上面分配的数组。<br/><br/>&emsp;&emsp;<sub>由于`java.lang.invoke.MethodHandle`的`invokeWithArguments`方法的行为，引导方法句柄的类型描述符不需要跟参数的运行时类型完全匹配。比如，引导方法句柄的第二个参数类型（对应上面数组中的第一个元素中给出的非限定名）可以是`Object`而非`String`。如果引导方法句柄是变参的，那么部分或全部参数都可以整合到最后的数组参数中。</sub><br/><br/>调用发生在尝试解析符号引用的线程中。如果有多个这种线程，那么可能会并发调用引导方法句柄。访问全局应用数据的引导方法面对竞争条件时也要照常进行保护。<br/><br/>如果由于抛出`Error`或其子类实例导致调用失败，解析也因此失败。<br/><br/>如果调用失败不是因为抛出`Error`或其子类导致的，那么以`BootstrapMethodError`解析失败，并且其原因为真正抛出的异常。<br/><br/>如果多个线程对这个符号引用并发调用引导方法句柄，JVM要从调用结果中选择其中一个并装载它，对所有线程可见。对这个符号引用的其它引导方法还可以继续执行并完成，但是它们的结果就忽略掉了。

第三步，验证引导方法句柄调用得到的`reference`和*o*，过程如下：

- 如果*R*是一个动态计算常量的符号引用，那么*o*就要转换成类型*T*，也就是*R*给出的字段描述符中表达的类型。<br/><br/>*o*的转换类似于以方法描述符`(Ljava/lang/Object;)T`调用`MH.invoke(o)`，*MH*则是一个方法句柄，它的产生类似于调用`java.lang.invoke.MethodHandles`的`identity`方法，参数则代表`Object`类。<br/><br/>*o*的转换结果就是解析的结果。<br/><br/>如果因为抛出了一个`NullPointerException`或一个`ClassCastException`导致转换失败，则以`BootstrapMethodError`导致解析失败。<br/><br/>奇怪，慢慢变成了翻译机器，自己并不懂自己翻译的东西是什么，只是觉得在顺理成章的翻译着。
- 如果*R*是一个动态计算调用点的符号引用，那么如果满足下列全部条件，*o*就是解析的结果：
    - *o*不是`null`。
    - *o*是一个`java.lang.invoke.CallSite`或其子类的实例。
    - `java.lang.invoke.CallSite`的类型语义上和*R*给出的方法描述符相同。

&emsp;&emsp;如果*o*不具备这些条件，那么以`BootstrapMethodError`解析失败。

上面的步骤中执行计算的时候都是“类似于调用”某种方法。在每种场景中，具体的调用行为都由*invokestatic*或*invokevirtual*的规范给出。调用都发生在线程中，而且都来自于尝试解析符号引用*R*的类。但是，在运行时常量池中不需要存在对应的方法引用，也不需要用特定的方法操作数栈，而且不强制规定调用时方法`Code`属性中`max_stack`的值。

如果同时有多个线程尝试解析*R*，引导方法可能会并发调用。因此，方法全局应用数据的引导方法需要对竞争条件做好预防控制。