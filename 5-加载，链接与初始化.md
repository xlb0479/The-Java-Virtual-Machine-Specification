# 5 加载，链接与初始化

JVM会动态加载、链接、初始化类和接口。加载就是找到指定名字的类或接口类型的二进制表达，然后
根据二进制表达*创建*这个接口或类。链接就是把一个类或接口并入JVM的运行时状态，这样才能够执行。类或接口的初始化包含了类或接口的初始化方法`<clinit>`（§2.9.2）的执行。

在本章中，（嘿嘿，终于弄完了第四章）§5.1讲的是JVM如何从类或接口的二进制表达中获取符号引用。§5.2讲的是JVM是如何启动加载、链接以及初始化过程的。§5.3给出类和接口的二进制表达是如何被类加载器加载以及类和接口是如何被创建的。§5.4讲链接。§5.5会详细说说类和接口的初始化。§5.6介绍本地方法的绑定。最后，§5.7会说一下JVM是什么时候退出的。

## 5.1 运行时常量池

JVM为每个类和接口维护了一个运行时常量池（§2.5.5）。这个数据结构为常见编程语言的符号表提供了大量支持。类或接口的二进制表达中的`constant_pool`表（§4.4）用来在类或接口创建时构造运行时常量池（§5.3）。

在运行时常量池中一共有两种记录：符号引用，后期会做解析（§5.4.3），以及静态常量，不需要进一步处理。

运行时常量池中的符号引用来自于`constant_pool`表中的记录，跟里面的结构一致：

- 对类或接口的符号引用来自于`CONSTANT_Class_info`结构体（§4.4.1）。这种引用按照下面的形式给出类或接口䣌名字：
    - 对于非数组类或接口，名字就是类或接口的二进制名（§4.2.1）。
    - 对于*n*维数组类，名字开头是*n*个ASCII字符`[`，然后是它的元素类型：
        - 如果元素类型是基本类型，则用对应的字段描述符（§4.3.2）表达。
        - 否则，如果元素类型是引用类型，则用ASCII字符`L`开头，然后是元素类型的二进制名，然后跟一个ASCII字符`;`。

&emsp;&emsp;本章中提到类或接口的名字时，都应该理解为上面说的这种格式。（这也是`Class.getName`方法返回的格式。）

- 对类或接口字段的符号引用来自于`CONSTANT_Fieldref_info`结构体（§4.4.2）。这种引用给出了字段的名字和描述符，以及该字段所属的类或接口的符号引用。
- 对类中方法的符号引用来自`CONSTANT_Methodref_info`结构体（§4.4.2）。这个引用给出了方法的名字和描述符，以及到该方法所属类的符号引用。
- 对接口中方法的符号引用来自于`CONSTANT_InterfaceMethodref_info`结构体（§4.4.2）。这个引用给出了接口方法的名字和描述符，以及方法所在接口的符号引用。
- 方法句柄的符号引用来自于`CONSTANT_MethodHandle_info`结构体（§4.4.8）。这个引用给出了类或接口字段的符号引用，或者是类方法符号引用，也可能是接口方法的符号引用，要看方法句柄的类型。
- 方法类型的符号引用来自于`CONSTANT_MethodType_info`结构体（§4.4.9）。这个引用给出了方法描述符（§4.3.3）。
- *动态计算常量*的符号引用来自于`CONSTANT_Dynamic_info`结构体（§4.4.10）。这种符号引用提供了：
    - 到方法句柄的符号引用，用来计算常量的值；
    - 一个符号引用和静态常量序列，方法句柄调用的时候作为*静态参数*。
    - 一个未限定名和一个字段描述符。

运行时常量池中的静态常量还同样来自于`constant_pool`表，和其中每条记录的结构保持一致：

- 字符串常量是`String`类实例的一个`reference`，它来自于`CONSTANT_String_info`结构体（§4.4.3）。要搞出一个字符串常量，JVM要检查`CONSTANT_String_info`结构体给出的代码点序列：
    - 如果某个`String`类实例的`String.intern`方法被调用过，并且它包含的Unicode代码点序列跟当前`CONSTANT_String_info`结构体给出的一样，那么这个字符串常量就是同一个`String`类实例的`reference`。
    - 否则，就创建一个新的`String`类的实例，包含该`CONSTANT_String_info`结构体给出的Unicode代码点序列。该字符串常量就是对这个新实例的一个`reference`。最终，在这个新实例上调用`String.intern`方法。
- 数字常量来自于`CONSTANT_Integer_info`、`CONSTANT_Float_info`、`CONSTANT_Long_info`以及`CONSTANT_Double_info`结构体（§4.4.4，§4.4.5）。

&emsp;&emsp;注意`CONSTANT_Float_info`结构体代表的是IEEE754的单精度格式值，`CONSTANT_Double_info`结构体代表的是IEEE754的双精度格式值。因此，从这些结构体搞出来的数值常量必须要用IEEE754单精度或双精度格式来表达。

`constant_pool`表中其余的结构体——描述性的结构体`CONSTANT_NameAndType_info`、`CONSTANT_Module_info`、`CONSTANT_Package_info`，以及基础型的结构体`CONSTANT_Utf8_info`——只在构建运行时常量池时间接用到。运行时常量池中不存在跟这些结构体直接对应的记录。

运行时常量池中某些记录是*可加载的*，也就是说：

- 它们可以被*ldc*系列指令压栈（§ldc，§ldc_w，§ldc2_w）。
- 它们可以是动态计算常量和调用点的引导方法的静态参数（§5.4.3.6）。

如果`constant_pool`表中的记录是可加载的（见表4.4-C），那么用它搞出来的运行时常量池记录也是可加载的。以此类推，运行时常量池中的以下记录都是可加载的：

- 类和接口的符号引用
- 方法句柄的符号引用
- 动态计算常量的符号引用
- 静态常量

## 5.2 JVM启动

JVM启动的时候要用引导类加载器（§5.3.1）或用户自定义类加载器（§5.3.2）创建一个初始类或接口。然后JVM为这个初始类或接口做链接，初始化，然后调用`public static`方法`void main(String[])`。该方法的调用派生出后续的所有操作。组成`main`方法的JVM指令的执行可能会链接（并创建）其他的类和接口，并调用其它的方法。

这个初始类或接口要以实现特定的方式来定义。比如这个初始类或接口可以被作为一个命令行参数。或者，JVM在实现的时候自己可以提供一个初始类，用它创建一个类加载器，然后再返回来加载一个应用。只要是按照前面讲的规范来，初始类或接口也可以干其它的事儿。

## 5.3 创建与加载

要创建一个名为*N*的类或接口*C*，就是要在JVM方法区（§2.5.4）中创建出与实现相关的*C*的内部表达。

类或接口的创建被另一个类或接口*D*触发，而它的运行时常量池通过名字*N*符号引用了*C*（§5.4.3.1）。如果*N*指的不是数组类，那么JVM就要用一个*类加载器*来定位一个名为*N*的类或接口的二进制表达（§4.1）。当类加载器定位到了二进制表达，它要反过来依赖JVM从这个二进制表达中搞出类或接口*C*，然后在方法区中创建*C*。数组类不具备外部二进制表达；JVM创建它们的时候走了不同的流程。

&emsp;&emsp;<sub>类或接口的创建还可以通过*D*调用某些JavaSE平台类库（§2.12）来触发，比如反射。</sub>

一共有两种类加载器：JVM提供的引导类加载器，以及用户定义的类加载器。用户定义的类加载器都属于是抽象类`ClassLoader`的子类的实例。应用借助用户定义的类加载器来扩展JVM动态创建类时的行为。用户定义的类加载器可以用自定义的源来创建类。比如一个类可以从网络上下载下来，在运行时生成出来，或者是从某个加密文件中提取出来。

当JVM请求一个类加载器*L*定位一个名为*N*的类或接口时，*L*要加载*N*代表的类或接口*C*。*L*可以直接加载*C*，定位到二进制表达并请求JVM从二进制表达中创建出*C*。或者也可以间接加载，委派给另一个类加载器，对方可以直接或间接的加载*C*。

如果是直接加载，我们就说*L* *定义了* *C*，或者说*L*是*C*的*定义加载器*。

不管是直接还是间接，我们说*L* *启动了* *C*的加载，或者也可以说*L*是*C*的*启动加载器*。

由于类加载器的委派机制，依JVM请求启动加载的加载器<i>L<sub>1</sub></i>，跟完成类或接口定义加载的加载器<i>L<sub>2</sub></i>，可能不是同一个。此时，我们说<i>L<sub>1</sub></i>和<i>L<sub>2</sub></i>都*启动了* *C*的加载，或者说<i>L<sub>1</sub></i>和<i>L<sub>2</sub></i>都是*C*的*启动加载器*。在<i>L<sub>1</sub></i>和<i>L<sub>2</sub></i>之间委派链上的其它加载器并不被当成是*C*的启动加载器。

有的时候我们会用下面的标记法来表达一个类或接口，而不是用*C*或*D*这种标识符：

- <code>&lt;<i>N</i>, <i>L<sub>d</sub></i>&gt;</code>——其中*N*代表类或接口名，<i>L<sub>d</sub></i>代表类或接口的定义加载器。
- <code><i>N<sup>L<sub>i</sub></sup></i></code>——其中*N*代表类或接口名，<i>L<sub>i</sub></i>代表类或接口的启动加载器。

&emsp;&emsp;<sub>需要说明的是类或接口的*加载*是JVM和类加载器（如果出现委派，可能有多个类加载器）共同的努力成果。加载过程最终的结果就是JVM在方法区中创建了一个类或接口，所以我们也常说一个类或接口*因为加载所以创建*。</sub>

&emsp;&emsp;<sub>加载过程这种反反复复的复杂本质，加上还能让用户自定义类加载器来展示各种行为，意味着在JVM创建一个类或接口*之后*，在每个参与加载的类加载器完成*之前*，是可以抛出异常的。这种定义考虑到了我们常说的*类或接口的加载与创建过程*中的异常。</sub>

JVM采用以下三种方式之一来创建类或接口*D*的运行时常量池中名为*N*的类或接口*C*：

- 如果*N*代表的是非数组类或接口，而且*D*是由引导类加载器定义的，那么引导类加载器启动*C*的加载（§5.3.1）。
- 如果*N*代表的是非数组类或接口，而且*D*是由用户定义的类加载器所定义的，那么就是同样的用户自定义类加载器来启动*C*的加载（§5.3.2）。
- 如果*N*代表一个数组类，那么JVM在*D*的定义加载器配合下创建*N*所指定的数组类*C*。

&emsp;&emsp;<sub>尽管*D*的定义加载器跟数组类的创建过程有关，但是并不用它来加载和创建数组类。</sub>

如果在类或接口的加载过程中——类加载器定位到二进制表达的时候，或者是JVM从二进制表达中创建类的时候——出错了，那么这个错误必须在程序中（直接或间接）用到当前被加载的类或接口时抛出来。

&emsp;&emsp;<sub>正常工作的类加载器应当具备这三种属性：<ul><li>给你同样的名字，你永远返回的都是同样的`Class`对象。</li><li>如果类加载器<i>L<sub>1</sub></i>把类*C*的加载委派给了另一个加载器<i>L<sub>2</sub></i>，那么对于任意类型*T*，如果它是*C*的直接父类或父接口类型，或者是*C*中某个字段的类型，或者是*C*中某个方法或构造器的形参的类型，或者是*C*中某个方法的返回类型，<i>L<sub>1</sub></i>和<i>L<sub>2</sub></i>要返回相同的`Class`对象。</li><li>如果一个用户自定义的类加载器对类和接口的二进制表达做了预提取，或者一趟加载了一组相关的类，如果出现加载错误，必须在这些类或接口原本没有发生预提取的情况下在程序中可能出错的点上反馈出来。</li></ul></sub>

创建过后，一个类或接口就不能只靠名字来判断了，而是需要一对儿：名字（§4.2.1）和定义加载器。每个这样的类或接口只属于一个*运行时包*。一个类或接口的运行时包要靠包名以及该类或接口的定义加载器来决定。

### 5.3.1 使用Bootstrap类加载器

使用引导类加载器加载并创建*N*所代表的类或接口*C*的过程如下。

首先，JVM要判断引导类加载器是否已经被记录成*N*代表的类或接口的启动加载器。如果是，那么这个类或接口就是*C*，不需要做类的加载和创建了。

否则，JVM把*N*作为一个参数，调用引导类加载器的一个方法。要加载*C*，引导类加载器通过一种平台相关的方式定位到一个可能的*C*的表达，然后请求JVM用引导类加载器从这个可能的表达中搞出一个*N*所代表的类或接口*C*，然后创建*C*，这里面离不开算法§5.3.5。

&emsp;&emsp;<sub>一般来说，一个类或接口都是放在一种层级化的文件系统中的一个文件中，类或接口的名字也会被编码到文件路径名中，辅助定位。</sub>

如果找到了一个*C*的可能的表达，但是从表达中往出搞*C*的时候失败了，那么*C*的加载和创建过程也因此而失败。

否则，*C*的加载和创建就算是成功了。

### 5.3.2 使用用户定义的类加载器

使用用户定义的类加载器*L*来加载和创建*N*代表的非数组类或接口*C*的过程如下。

首先，JVM要判断*L*是不是已经被记录成*N*代表的类或接口的启动加载器了。如果是，那么这个类或接口就是*C*，不需要做类的加载和创建了。

否则，JVM调用*L*上的`ClassLoader`类的`loadClass`方法，把类或接口的名字*N*传进去。要完成类或接口*C*的创建和加载，*L*必须要执行以下两种操作之一：

1. 类加载器*L*可以直接加载*C*。这要拿到一个字节数组，它可能能够把*C*表达成一个`ClassFile`结构体（§4.1），然后调用`ClassLoader`类的`defineClass`方法。调用这个方法可以让JVM用*L*从字节数组中搞出一个*N*代表的类或接口*C*，并创建*C*，也要用到算法§5.3.5。*L*要把`defineClass`的结果作为`loadClass`的结果。
2. 类加载器*L*可以间接加载*C*，这是把*C*的加载委派给另外的类加载器*L'*。这个过程是要把参数*N*传给*L'*的一个方法（一般是`ClassLoader`类的`loadClass`方法）。*L*要把该方法的结果作为`loadClass`的结果。

不管用哪种方法都要遵守下面的规则：

- 如果一个类加载器无法找到*N*代表的类或接口的一个可能的表达，那么必须抛出一个`ClassNotFoundException`。*C*的加载和创建过程进而失败，报出一个由`ClassNotFoundException`导致的`NoClassDefFoundError`。
- 如果一个类加载找到了*C*的一个可能的表达，但是从里面往出搞*C*的时候失败了，那么*C*的加载和创建过程就以同样的原因失败。
- 如果一个类加载器抛出了一个非`ClassNotFoundException`的异常，那么*C*的加载和创建过程就以同样的原因失败。

如果调用*L*的`loadClass`得到了一个结果，那么：

- 如果结果是`null`，或者是一个名字不叫*N*的类或接口，那么就要丢弃该结果，加载和创建过程以`NoClassDefFoundError`失败告终。
- 否则，结果是创建好的类或接口*C*。JVM把*L*记录为*C*的启动加载器（§5.3.4）。*C*的加载和创建成功了。

&emsp;&emsp;&emsp;&emsp;<sub>从JDK1.1开始，Oracle的JVM让类加载器加载类或接口的时候，会调用单个参数的`loadClass`方法。参数就是要加载的类或接口的名字。还有一个俩参数的`loadClass`方法，第二个参数是一个`boolean`，表示是否要链接这个类或接口。JDK1.0.2中只有俩参的版本，因为Oracle的JVM实现要依赖它来链接被加载的类或接口。从JDK1.1开始，Oracle的JVM实现直接链接类或接口，不再依赖类加载器。</sub>

### 5.3.3 创建数组类

下面的步骤是通过类加载器*L*创建名为*N*的数组类*C*。*L*可能是一个引导类加载器或者是一个用户自定义的类加载器。

首先，JVM要判断*L*是否已经被记录为某个数组类的启动加载器了，而且这个数组类的元素类型就是*N*。如果是，那么它就是类*C*，不需要创建数组类了。

否则，执行下面的步骤来创建*C*：

1. 如果元素类型是一个`reference`类型，那么就对*L*递归式的应用本节介绍的算法（§5.3）来加载并创建*C*的元素类型。
2. JVM创建一个新的数组类，采用指定的元素类型以及维度。

&emsp;&emsp;&nbsp;&nbsp;&nbsp;如果元素类型是一个`reference`类型，那么JVM就把元素类型的定义加载器标记为*C*的定义加载器。否则，JVM就把引导类加载器标记为*C*的定义加载器。

&emsp;&emsp;&nbsp;&nbsp;&nbsp;否则，JVM就将*L*记录为*C*的启动加载器（§5.3.4）。

&emsp;&emsp;&nbsp;&nbsp;&nbsp;如果元素类型是一个`reference`类型，那么数组类的可访问性就有元素类型的可访问性决定（§5.4.4）。否则该数组类就可以被所有的类和接口访问。

### 5.3.4 加载约束

使用类加载器时要保证类型安全的链接是需要特殊注意的。可能存在不同的类加载器都在对*N*代表的类或接口启动加载，而且*N*在不同的加载器中可能代表不同的类或接口。

当一个类或接口<code><i>C</i> = &lt;<i>N<sub>1</sub></i>, <i>L<sub>1</sub></i>&gt;</code>符号引用了另一个类或接口<code><i>D</i> = &lt;<i>N<sub>2</sub></i>, <i>L<sub>2</sub></i>&gt;</code>的字段或方法，符号引用包含了声明字段类型或方法返回类型和参数类型的描述符。必须要保证字段或方法描述符中的任意类型名*N*被<i>L<sub>1</sub></i>和<i>L<sub>2</sub></i>加载时都代表同样的类或接口。

要保证这一点，JVM在准备（§5.4.2）和解析（§5.4.3）阶段搞了<code><i>N<sup>L<sub>1</sub></sup></i> = <i>N<sup>L<sub>2</sub></sup></i></code>这种形式的*加载约束*。为了强制满足该约束，JVM会在某些规定的时刻（见§5.3.1、§5.3.2、§5.3.3、§5.3.5），将特定的加载器记录为特定类的启动加载器。记录之后，JVM必须立刻检查有没有违反加载约束的地方。如果有，就撤回记录，然后JVM报一个`LinkageError`，加载过程继而失败。

同样，应用一条加载约束（见§5.4.2、§5.4.3.2、§5.4.3.3、§5.4.3.4）后JVM必须立刻检查看看是否存在违规的情况。如果有，新应用的加载约束就要撤回，然后JVM报一个`LinkageError`，过程继而失败（可能是在解析或准备阶段）。

JVM只会在我们提到的这些场景中检查是否存在加载约束被违反的情况。一个加载约束被违反，当且仅当以下四个条件全部成立：

- 存在一个加载器*L*，*L*已经被JVM记录为名为*N*的类*C*的启动加载器。
- 存在一个加载器*L'*，*L'*已经被JVM记录为名为*N*的类*C'*的启动加载器。
- 约束集合（的传递闭包）定义的等价关系为<code><i>N<sup>L</sup></i> = <i>N<sup>L'</sup></i></code>。
- <code><i>C</i> ≠ <i>C'</i></code>。

&emsp;&emsp;&emsp;&emsp;<sub>关于类加载器和类型安全的完备知识体系已经超出了本规范的范围。要想了解更加详细的知识，读者们可以去看Sheng Liang和Gilad Bracha的*JVM的动态类加载*（*这是1998年ACM SIGPLAN会议中关于面向对象编程系统、语言及应用议程中的一部分*）。</sub>

### 5.3.5 从class文件表达搞类

下面的步骤是用类加载器*L*从一个可能的`class`文件格式表达中搞出一个名为*N*的非数组类或接口*C*。

1. 首先，JVM要判断*L*是否已经被记录为*N*代表的类或接口的启动加载器。如果是，那么这次暗夜行动就是无效的，报出一个`LinkageError`。
2. 否则，JVM要尝试解析这个可能的表达。这个可能的表达可能实际上并不是*C*的一个有效表达，因此必须检查以下问题：
    - 如果这份可能的表达不是一个`ClassFile`结构体（§4.1，§4.8），那么就抛一个`ClassFormatError`。
    - 否则，如果这份可能的表达不属于受支持的大版本或小版本（§4.1），那么就抛一个`UnsupportedClassVersionError`。<br/><br/><sub>`UnsupportedClassVersionError`是`ClassFormatError`的一个子类，从JDK1.2引入的，为了可以方便的标识出尝试加载一个类但它的表达并不是受支持的`class`文件格式版本时导致的`ClassFormatError`。在JDK1.1以及这之前，如果版本不支持，就抛一个`NoClassDefFoundError`或`ClassFormatError`，取决于类是被系统类加载器还是用户自定义类加载器加载的。</sub><br/><br/>
    - 否则，如果这份可能的表达并不是名为*N*的类或接口，那就抛一个`NoClassDefFoundError`。<br/><br/>当这份可能的表达包含的`this_item`属性中声明的名字不是*N*，或者它的`access_flags`属性设置了`ACC_MODULE`标记时，就会出现上面说的情况。

3. 