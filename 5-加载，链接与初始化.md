# 5 加载，链接与初始化

JVM会动态加载、链接、初始化类和接口。加载就是找到指定名字的类或接口类型的二进制表达，然后
根据二进制表达*创建*这个接口或类。链接就是把一个类或接口并入JVM的运行时状态，这样才能够执行。类或接口的初始化包含了类或接口的初始化方法`<clinit>`（§2.9.2）的执行。

在本章中，（嘿嘿，终于弄完了第四章）§5.1讲的是JVM如何从类或接口的二进制表达中获取符号引用。§5.2讲的是JVM是如何启动加载、链接以及初始化过程的。§5.3给出类和接口的二进制表达是如何被类加载器加载以及类和接口是如何被创建的。§5.4讲链接。§5.5会详细说说类和接口的初始化。§5.6介绍本地方法的绑定。最后，§5.7会说一下JVM是什么时候退出的。

## 5.1 运行时常量池

JVM为每个类和接口维护了一个运行时常量池（§2.5.5）。这个数据结构为常见编程语言的符号表提供了大量支持。类或接口的二进制表达中的`constant_pool`表（§4.4）用来在类或接口创建时构造运行时常量池（§5.3）。

在运行时常量池中一共有两种记录：符号引用，后期会做解析（§5.4.3），以及静态常量，不需要进一步处理。

运行时常量池中的符号引用来自于`constant_pool`表中的记录，跟里面的结构一致：

- 对类或接口的符号引用来自于`CONSTANT_Class_info`结构体（§4.4.1）。这种引用按照下面的形式给出类或接口䣌名字：
    - 对于非数组类或接口，名字就是类或接口的二进制名（§4.2.1）。
    - 对于*n*维数组类，名字开头是*n*个ASCII字符`[`，然后是它的元素类型：
        - 如果元素类型是基本类型，则用对应的字段描述符（§4.3.2）表达。
        - 否则，如果元素类型是引用类型，则用ASCII字符`L`开头，然后是元素类型的二进制名，然后跟一个ASCII字符`;`。

&emsp;&emsp;本章中提到类或接口的名字时，都应该理解为上面说的这种格式。（这也是`Class.getName`方法返回的格式。）

- 对类或接口字段的符号引用来自于`CONSTANT_Fieldref_info`结构体（§4.4.2）。这种引用给出了字段的名字和描述符，以及该字段所属的类或接口的符号引用。
- 对类中方法的符号引用来自`CONSTANT_Methodref_info`结构体（§4.4.2）。这个引用给出了方法的名字和描述符，以及到该方法所属类的符号引用。
- 对接口中方法的符号引用来自于`CONSTANT_InterfaceMethodref_info`结构体（§4.4.2）。这个引用给出了接口方法的名字和描述符，以及方法所在接口的符号引用。
- 方法句柄的符号引用来自于`CONSTANT_MethodHandle_info`结构体（§4.4.8）。这个引用给出了类或接口字段的符号引用，或者是类方法符号引用，也可能是接口方法的符号引用，要看方法句柄的类型。
- 方法类型的符号引用来自于`CONSTANT_MethodType_info`结构体（§4.4.9）。这个引用给出了方法描述符（§4.3.3）。
- *动态计算常量*的符号引用来自于`CONSTANT_Dynamic_info`结构体（§4.4.10）。这种符号引用提供了：
    - 到方法句柄的符号引用，用来计算常量的值；
    - 一个符号引用和静态常量序列，方法句柄调用的时候作为*静态参数*。
    - 一个未限定名和一个字段描述符。

运行时常量池中的静态常量还同样来自于`constant_pool`表，和其中每条记录的结构保持一致：

- 字符串常量是`String`类实例的一个`reference`，它来自于`CONSTANT_String_info`结构体（§4.4.3）。要搞出一个字符串常量，JVM要检查`CONSTANT_String_info`结构体给出的代码点序列：
    - 如果某个`String`类实例的`String.intern`方法被调用过，并且它包含的Unicode代码点序列跟当前`CONSTANT_String_info`结构体给出的一样，那么这个字符串常量就是同一个`String`类实例的`reference`。
    - 否则，就创建一个新的`String`类的实例，包含该`CONSTANT_String_info`结构体给出的Unicode代码点序列。该字符串常量就是对这个新实例的一个`reference`。最终，在这个新实例上调用`String.intern`方法。
- 数字常量来自于`CONSTANT_Integer_info`、`CONSTANT_Float_info`、`CONSTANT_Long_info`以及`CONSTANT_Double_info`结构体（§4.4.4，§4.4.5）。

&emsp;&emsp;注意`CONSTANT_Float_info`结构体代表的是IEEE754的单精度格式值，`CONSTANT_Double_info`结构体代表的是IEEE754的双精度格式值。因此，从这些结构体搞出来的数值常量必须要用IEEE754单精度或双精度格式来表达。

`constant_pool`表中其余的结构体——描述性的结构体`CONSTANT_NameAndType_info`、`CONSTANT_Module_info`、`CONSTANT_Package_info`，以及基础型的结构体`CONSTANT_Utf8_info`——只在构建运行时常量池时间接用到。运行时常量池中不存在跟这些结构体直接对应的记录。

运行时常量池中某些记录是*可加载的*，也就是说：

- 它们可以被*ldc*系列指令压栈（§ldc，§ldc_w，§ldc2_w）。
- 它们可以是动态计算常量和调用点的引导方法的静态参数（§5.4.3.6）。

如果`constant_pool`表中的记录是可加载的（见表4.4-C），那么用它搞出来的运行时常量池记录也是可加载的。以此类推，运行时常量池中的以下记录都是可加载的：

- 类和接口的符号引用
- 方法句柄的符号引用
- 动态计算常量的符号引用
- 静态常量

## 5.2 JVM启动

JVM启动的时候要用引导类加载器（§5.3.1）或用户自定义类加载器（§5.3.2）创建一个初始类或接口。然后JVM为这个初始类或接口做链接，初始化，然后调用`public static`方法`void main(String[])`。该方法的调用派生出后续的所有操作。组成`main`方法的JVM指令的执行可能会链接（并创建）其他的类和接口，并调用其它的方法。

这个初始类或接口要以实现特定的方式来定义。比如这个初始类或接口可以被作为一个命令行参数。或者，JVM在实现的时候自己可以提供一个初始类，用它创建一个类加载器，然后再返回来加载一个应用。只要是按照前面讲的规范来，初始类或接口也可以干其它的事儿。