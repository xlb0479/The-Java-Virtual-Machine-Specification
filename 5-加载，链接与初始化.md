# 5 加载，链接与初始化

JVM会动态加载、链接、初始化类和接口。加载就是找到指定名字的类或接口类型的二进制表达，然后
根据二进制表达*创建*这个接口或类。链接就是把一个类或接口并入JVM的运行时状态，这样才能够执行。类或接口的初始化包含了类或接口的初始化方法`<clinit>`（§2.9.2）的执行。

在本章中，（嘿嘿，终于弄完了第四章）§5.1讲的是JVM如何从类或接口的二进制表达中获取符号引用。§5.2讲的是JVM是如何启动加载、链接以及初始化过程的。§5.3给出类和接口的二进制表达是如何被类加载器加载以及类和接口是如何被创建的。§5.4讲链接。§5.5会详细说说类和接口的初始化。§5.6介绍本地方法的绑定。最后，§5.7会说一下JVM是什么时候退出的。

## 5.1 运行时常量池

JVM为每个类和接口维护了一个运行时常量池（§2.5.5）。这个数据结构为常见编程语言的符号表提供了大量支持。类或接口的二进制表达中的`constant_pool`表（§4.4）用来在类或接口创建时构造运行时常量池（§5.3）。

在运行时常量池中一共有两种记录：符号引用，后期会做解析（§5.4.3），以及静态常量，不需要进一步处理。

运行时常量池中的符号引用来自于`constant_pool`表中的记录，跟里面的结构一致：

- 对类或接口的符号引用来自于`CONSTANT_Class_info`结构体（§4.4.1）。这种引用按照下面的形式给出类或接口䣌名字：
    - 对于非数组类或接口，名字就是类或接口的二进制名（§4.2.1）。
    - 对于*n*维数组类，名字开头是*n*个ASCII字符`[`，然后是它的元素类型：
        - 如果元素类型是基本类型，则用对应的字段描述符（§4.3.2）表达。
        - 否则，如果元素类型是引用类型，则用ASCII字符`L`开头，然后是元素类型的二进制名，然后跟一个ASCII字符`;`。

&emsp;&emsp;本章中提到类或接口的名字时，都应该理解为上面说的这种格式。（这也是`Class.getName`方法返回的格式。）

- 对类或接口字段的符号引用来自于`CONSTANT_Fieldref_info`结构体（§4.4.2）。这种引用给出了字段的名字和描述符，以及该字段所属的类或接口的符号引用。
- 对类中方法的符号引用来自`CONSTANT_Methodref_info`结构体（§4.4.2）。这个引用给出了方法的名字和描述符，以及到该方法所属类的符号引用。
- 对接口中方法的符号引用来自于`CONSTANT_InterfaceMethodref_info`结构体（§4.4.2）。这个引用给出了接口方法的名字和描述符，以及方法所在接口的符号引用。
- 方法句柄的符号引用来自于`CONSTANT_MethodHandle_info`结构体（§4.4.8）。这个引用给出了类或接口字段的符号引用，或者是类方法符号引用，也可能是接口方法的符号引用，要看方法句柄的类型。
- 方法类型的符号引用来自于`CONSTANT_MethodType_info`结构体（§4.4.9）。这个引用给出了方法描述符（§4.3.3）。
- *动态计算常量*的符号引用来自于`CONSTANT_Dynamic_info`结构体（§4.4.10）。这种符号引用提供了：
    - 到方法句柄的符号引用，用来计算常量的值；
    - 一个符号引用和静态常量序列，方法句柄调用的时候作为*静态参数*。
    - 一个未限定名和一个字段描述符。

运行时常量池中的静态常量还同样来自于`constant_pool`表，和其中每条记录的结构保持一致：

- 字符串常量是`String`类实例的一个`reference`，它来自于`CONSTANT_String_info`结构体（§4.4.3）。要搞出一个字符串常量，JVM要检查`CONSTANT_String_info`结构体给出的代码点序列：
    - 如果某个`String`类实例的`String.intern`方法被调用过，并且它包含的Unicode代码点序列跟当前`CONSTANT_String_info`结构体给出的一样，那么这个字符串常量就是同一个`String`类实例的`reference`。
    - 否则，就创建一个新的`String`类的实例，包含该`CONSTANT_String_info`结构体给出的Unicode代码点序列。该字符串常量就是对这个新实例的一个`reference`。最终，在这个新实例上调用`String.intern`方法。
- 数字常量来自于`CONSTANT_Integer_info`、`CONSTANT_Float_info`、`CONSTANT_Long_info`以及`CONSTANT_Double_info`结构体（§4.4.4，§4.4.5）。

&emsp;&emsp;注意`CONSTANT_Float_info`结构体代表的是IEEE754的单精度格式值，`CONSTANT_Double_info`结构体代表的是IEEE754的双精度格式值。因此，从这些结构体搞出来的数值常量必须要用IEEE754单精度或双精度格式来表达。

`constant_pool`表中其余的结构体——描述性的结构体`CONSTANT_NameAndType_info`、`CONSTANT_Module_info`、`CONSTANT_Package_info`，以及基础型的结构体`CONSTANT_Utf8_info`——只在构建运行时常量池时间接用到。运行时常量池中不存在跟这些结构体直接对应的记录。

运行时常量池中某些记录是*可加载的*，也就是说：

- 它们可以被*ldc*系列指令压栈（§ldc，§ldc_w，§ldc2_w）。
- 它们可以是动态计算常量和调用点的引导方法的静态参数（§5.4.3.6）。

如果`constant_pool`表中的记录是可加载的（见表4.4-C），那么用它搞出来的运行时常量池记录也是可加载的。以此类推，运行时常量池中的以下记录都是可加载的：

- 类和接口的符号引用
- 方法句柄的符号引用
- 动态计算常量的符号引用
- 静态常量

## 5.2 JVM启动

JVM启动的时候要用引导类加载器（§5.3.1）或用户自定义类加载器（§5.3.2）创建一个初始类或接口。然后JVM为这个初始类或接口做链接，初始化，然后调用`public static`方法`void main(String[])`。该方法的调用派生出后续的所有操作。组成`main`方法的JVM指令的执行可能会链接（并创建）其他的类和接口，并调用其它的方法。

这个初始类或接口要以实现特定的方式来定义。比如这个初始类或接口可以被作为一个命令行参数。或者，JVM在实现的时候自己可以提供一个初始类，用它创建一个类加载器，然后再返回来加载一个应用。只要是按照前面讲的规范来，初始类或接口也可以干其它的事儿。

## 5.3 创建与加载

要创建一个名为*N*的类或接口*C*，就是要在JVM方法区（§2.5.4）中创建出与实现相关的*C*的内部表达。

类或接口的创建被另一个类或接口*D*触发，而它的运行时常量池通过名字*N*符号引用了*C*（§5.4.3.1）。如果*N*指的不是数组类，那么JVM就要用一个*类加载器*来定位一个名为*N*的类或接口的二进制表达（§4.1）。当类加载器定位到了二进制表达，它要反过来依赖JVM从这个二进制表达中搞出类或接口*C*，然后在方法区中创建*C*。数组类不具备外部二进制表达；JVM创建它们的时候走了不同的流程。

&emsp;&emsp;<sub>类或接口的创建还可以通过*D*调用某些JavaSE平台类库（§2.12）来触发，比如反射。</sub>

一共有两种类加载器：JVM提供的引导类加载器，以及用户定义的类加载器。用户定义的类加载器都属于是抽象类`ClassLoader`的子类的实例。应用借助用户定义的类加载器来扩展JVM动态创建类时的行为。用户定义的类加载器可以用自定义的源来创建类。比如一个类可以从网络上下载下来，在运行时生成出来，或者是从某个加密文件中提取出来。

当JVM请求一个类加载器*L*定位一个名为*N*的类或接口时，*L*要加载*N*代表的类或接口*C*。*L*可以直接加载*C*，定位到二进制表达并请求JVM从二进制表达中创建出*C*。或者也可以间接加载，委派给另一个类加载器，对方可以直接或间接的加载*C*。

如果是直接加载，我们就说*L* *定义了* *C*，或者说*L*是*C*的*定义加载器*。

不管是直接还是间接，我们说*L* *启动了* *C*的加载，或者也可以说*L*是*C*的*启动加载器*。

由于类加载器的委派机制，依JVM请求启动加载的加载器<i>L<sub>1</sub></i>，跟完成类或接口定义加载的加载器<i>L<sub>2</sub></i>，可能不是同一个。此时，我们说<i>L<sub>1</sub></i>和<i>L<sub>2</sub></i>都*启动了* *C*的加载，或者说<i>L<sub>1</sub></i>和<i>L<sub>2</sub></i>都是*C*的*启动加载器*。在<i>L<sub>1</sub></i>和<i>L<sub>2</sub></i>之间委派链上的其它加载器并不被当成是*C*的启动加载器。

有的时候我们会用下面的标记法来表达一个类或接口，而不是用*C*或*D*这种标识符：

- <code>&lt;<i>N</i>, <i>L<sub>d</sub></i>&gt;</code>——其中*N*代表类或接口名，<i>L<sub>d</sub></i>代表类或接口的定义加载器。
- <code><i>N<sup>L<sub>i</sub></sup></i></code>——其中*N*代表类或接口名，<i>L<sub>i</sub></i>代表类或接口的启动加载器。

&emsp;&emsp;<sub>需要说明的是类或接口的*加载*是JVM和类加载器（如果出现委派，可能有多个类加载器）共同的努力成果。加载过程最终的结果就是JVM在方法区中创建了一个类或接口，所以我们也常说一个类或接口*因为加载所以创建*。</sub>

&emsp;&emsp;<sub>加载过程这种反反复复的复杂本质，加上还能让用户自定义类加载器来展示各种行为，意味着在JVM创建一个类或接口*之后*，在每个参与加载的类加载器完成*之前*，是可以抛出异常的。这种定义考虑到了我们常说的*类或接口的加载与创建过程*中的异常。</sub>

JVM采用以下三种方式之一来创建类或接口*D*的运行时常量池中名为*N*的类或接口*C*：

- 如果*N*代表的是非数组类或接口，而且*D*是由引导类加载器定义的，那么引导类加载器启动*C*的加载（§5.3.1）。
- 如果*N*代表的是非数组类或接口，而且*D*是由用户定义的类加载器所定义的，那么就是同样的用户自定义类加载器来启动*C*的加载（§5.3.2）。
- 如果*N*代表一个数组类，那么JVM在*D*的定义加载器配合下创建*N*所指定的数组类*C*。

&emsp;&emsp;<sub>尽管*D*的定义加载器跟数组类的创建过程有关，但是并不用它来加载和创建数组类。</sub>

如果在类或接口的加载过程中——类加载器定位到二进制表达的时候，或者是JVM从二进制表达中创建类的时候——出错了，那么这个错误必须在程序中（直接或间接）用到当前被加载的类或接口时抛出来。

&emsp;&emsp;<sub>正常工作的类加载器应当具备这三种属性：<ul><li>给你同样的名字，你永远返回的都是同样的`Class`对象。</li><li>如果类加载器<i>L<sub>1</sub></i>把类*C*的加载委派给了另一个加载器<i>L<sub>2</sub></i>，那么对于任意类型*T*，如果它是*C*的直接父类或父接口类型，或者是*C*中某个字段的类型，或者是*C*中某个方法或构造器的形参的类型，或者是*C*中某个方法的返回类型，<i>L<sub>1</sub></i>和<i>L<sub>2</sub></i>要返回相同的`Class`对象。</li><li>如果一个用户自定义的类加载器对类和接口的二进制表达做了预提取，或者一趟加载了一组相关的类，如果出现加载错误，必须在这些类或接口原本没有发生预提取的情况下在程序中可能出错的点上反馈出来。</li></ul></sub>

创建过后，一个类或接口就不能只靠名字来判断了，而是需要一对儿：名字（§4.2.1）和定义加载器。每个这样的类或接口只属于一个*运行时包*。一个类或接口的运行时包要靠包名以及该类或接口的定义加载器来决定。

### 5.3.1 使用Bootstrap类加载器

使用引导类加载器加载并创建*N*所代表的类或接口*C*的过程如下。

首先，JVM要判断引导类加载器是否已经被记录成*N*代表的类或接口的启动加载器。如果是，那么这个类或接口就是*C*，不需要做类的加载和创建了。

否则，JVM把*N*作为一个参数，调用引导类加载器的一个方法。要加载*C*，引导类加载器通过一种平台相关的方式定位到一个可能的*C*的表达，然后请求JVM用引导类加载器从这个可能的表达中搞出一个*N*所代表的类或接口*C*，然后创建*C*，这里面离不开算法§5.3.5。

&emsp;&emsp;<sub>一般来说，一个类或接口都是放在一种层级化的文件系统中的一个文件中，类或接口的名字也会被编码到文件路径名中，辅助定位。</sub>

如果找到了一个*C*的可能的表达，但是从表达中往出搞*C*的时候失败了，那么*C*的加载和创建过程也因此而失败。

否则，*C*的加载和创建就算是成功了。

### 5.3.2 使用用户定义的类加载器

使用用户定义的类加载器*L*来加载和创建*N*代表的非数组类或接口*C*的过程如下。

首先，JVM要判断*L*是不是已经被记录成*N*代表的类或接口的启动加载器了。如果是，那么这个类或接口就是*C*，不需要做类的加载和创建了。

否则，JVM调用*L*上的`ClassLoader`类的`loadClass`方法，把类或接口的名字*N*传进去。要完成类或接口*C*的创建和加载，*L*必须要执行以下两种操作之一：

1. 类加载器*L*可以直接加载*C*。这要拿到一个字节数组，它可能能够把*C*表达成一个`ClassFile`结构体（§4.1），然后调用`ClassLoader`类的`defineClass`方法。调用这个方法可以让JVM用*L*从字节数组中搞出一个*N*代表的类或接口*C*，并创建*C*，也要用到算法§5.3.5。*L*要把`defineClass`的结果作为`loadClass`的结果。
2. 类加载器*L*可以间接加载*C*，这是把*C*的加载委派给另外的类加载器*L'*。这个过程是要把参数*N*传给*L'*的一个方法（一般是`ClassLoader`类的`loadClass`方法）。*L*要把该方法的结果作为`loadClass`的结果。

不管用哪种方法都要遵守下面的规则：

- 如果一个类加载器无法找到*N*代表的类或接口的一个可能的表达，那么必须抛出一个`ClassNotFoundException`。*C*的加载和创建过程进而失败，报出一个由`ClassNotFoundException`导致的`NoClassDefFoundError`。
- 如果一个类加载找到了*C*的一个可能的表达，但是从里面往出搞*C*的时候失败了，那么*C*的加载和创建过程就以同样的原因失败。
- 如果一个类加载器抛出了一个非`ClassNotFoundException`的异常，那么*C*的加载和创建过程就以同样的原因失败。

如果调用*L*的`loadClass`得到了一个结果，那么：

- 如果结果是`null`，或者是一个名字不叫*N*的类或接口，那么就要丢弃该结果，加载和创建过程以`NoClassDefFoundError`失败告终。
- 否则，结果是创建好的类或接口*C*。JVM把*L*记录为*C*的启动加载器（§5.3.4）。*C*的加载和创建成功了。

&emsp;&emsp;&emsp;&emsp;<sub>从JDK1.1开始，Oracle的JVM让类加载器加载类或接口的时候，会调用单个参数的`loadClass`方法。参数就是要加载的类或接口的名字。还有一个俩参数的`loadClass`方法，第二个参数是一个`boolean`，表示是否要链接这个类或接口。JDK1.0.2中只有俩参的版本，因为Oracle的JVM实现要依赖它来链接被加载的类或接口。从JDK1.1开始，Oracle的JVM实现直接链接类或接口，不再依赖类加载器。</sub>

### 5.3.3 创建数组类

下面的步骤是通过类加载器*L*创建名为*N*的数组类*C*。*L*可能是一个引导类加载器或者是一个用户自定义的类加载器。

首先，JVM要判断*L*是否已经被记录为某个数组类的启动加载器了，而且这个数组类的元素类型就是*N*。如果是，那么它就是类*C*，不需要创建数组类了。

否则，执行下面的步骤来创建*C*：

1. 如果元素类型是一个`reference`类型，那么就对*L*递归式的应用本节介绍的算法（§5.3）来加载并创建*C*的元素类型。
2. JVM创建一个新的数组类，采用指定的元素类型以及维度。

&emsp;&emsp;&nbsp;&nbsp;&nbsp;如果元素类型是一个`reference`类型，那么JVM就把元素类型的定义加载器标记为*C*的定义加载器。否则，JVM就把引导类加载器标记为*C*的定义加载器。

&emsp;&emsp;&nbsp;&nbsp;&nbsp;否则，JVM就将*L*记录为*C*的启动加载器（§5.3.4）。

&emsp;&emsp;&nbsp;&nbsp;&nbsp;如果元素类型是一个`reference`类型，那么数组类的可访问性就有元素类型的可访问性决定（§5.4.4）。否则该数组类就可以被所有的类和接口访问。

### 5.3.4 加载约束

使用类加载器时要保证类型安全的链接是需要特殊注意的。可能存在不同的类加载器都在对*N*代表的类或接口启动加载，而且*N*在不同的加载器中可能代表不同的类或接口。

当一个类或接口<code><i>C</i> = &lt;<i>N<sub>1</sub></i>, <i>L<sub>1</sub></i>&gt;</code>符号引用了另一个类或接口<code><i>D</i> = &lt;<i>N<sub>2</sub></i>, <i>L<sub>2</sub></i>&gt;</code>的字段或方法，符号引用包含了声明字段类型或方法返回类型和参数类型的描述符。必须要保证字段或方法描述符中的任意类型名*N*被<i>L<sub>1</sub></i>和<i>L<sub>2</sub></i>加载时都代表同样的类或接口。

要保证这一点，JVM在准备（§5.4.2）和解析（§5.4.3）阶段搞了<code><i>N<sup>L<sub>1</sub></sup></i> = <i>N<sup>L<sub>2</sub></sup></i></code>这种形式的*加载约束*。为了强制满足该约束，JVM会在某些规定的时刻（见§5.3.1、§5.3.2、§5.3.3、§5.3.5），将特定的加载器记录为特定类的启动加载器。记录之后，JVM必须立刻检查有没有违反加载约束的地方。如果有，就撤回记录，然后JVM报一个`LinkageError`，加载过程继而失败。

同样，应用一条加载约束（见§5.4.2、§5.4.3.2、§5.4.3.3、§5.4.3.4）后JVM必须立刻检查看看是否存在违规的情况。如果有，新应用的加载约束就要撤回，然后JVM报一个`LinkageError`，过程继而失败（可能是在解析或准备阶段）。

JVM只会在我们提到的这些场景中检查是否存在加载约束被违反的情况。一个加载约束被违反，当且仅当以下四个条件全部成立：

- 存在一个加载器*L*，*L*已经被JVM记录为名为*N*的类*C*的启动加载器。
- 存在一个加载器*L'*，*L'*已经被JVM记录为名为*N*的类*C'*的启动加载器。
- 约束集合（的传递闭包）定义的等价关系为<code><i>N<sup>L</sup></i> = <i>N<sup>L'</sup></i></code>。
- <code><i>C</i> ≠ <i>C'</i></code>。

&emsp;&emsp;&emsp;&emsp;<sub>关于类加载器和类型安全的完备知识体系已经超出了本规范的范围。要想了解更加详细的知识，读者们可以去看Sheng Liang和Gilad Bracha的*JVM的动态类加载*（*这是1998年ACM SIGPLAN会议中关于面向对象编程系统、语言及应用议程中的一部分*）。</sub>

### 5.3.5 从class文件表达搞类

下面的步骤是用类加载器*L*从一个可能的`class`文件格式表达中搞出一个名为*N*的非数组类或接口*C*。

1. 首先，JVM要判断*L*是否已经被记录为*N*代表的类或接口的启动加载器。如果是，那么这次暗夜行动就是无效的，报出一个`LinkageError`。
2. 否则，JVM要尝试解析这个可能的表达。这个可能的表达可能实际上并不是*C*的一个有效表达，因此必须检查以下问题：
    - 如果这份可能的表达不是一个`ClassFile`结构体（§4.1，§4.8），那么就抛一个`ClassFormatError`。
    - 否则，如果这份可能的表达不属于受支持的大版本或小版本（§4.1），那么就抛一个`UnsupportedClassVersionError`。<br/><br/><sub>`UnsupportedClassVersionError`是`ClassFormatError`的一个子类，从JDK1.2引入的，为了可以方便的标识出尝试加载一个类但它的表达并不是受支持的`class`文件格式版本时导致的`ClassFormatError`。在JDK1.1以及这之前，如果版本不支持，就抛一个`NoClassDefFoundError`或`ClassFormatError`，取决于类是被系统类加载器还是用户自定义类加载器加载的。</sub><br/><br/>
    - 否则，如果这份可能的表达并不是名为*N*的类或接口，那就抛一个`NoClassDefFoundError`。<br/><br/>当这份可能的表达包含的`this_item`属性中声明的名字不是*N*，或者它的`access_flags`属性设置了`ACC_MODULE`标记时，就会出现上面说的情况。
3. 如果*C*有一个直接父类，那么从*C*到它的直接父类的符号引用的解析使用§5.4.3.1中的算法。注意如果*C*是一个接口，那么它的直接父类必须是`Object`，而且必须得是已经完成加载了的。只有`Object`不存在直接父类。<br/><br/>类或接口解析失败时抛出的异常都可以在往出搞类的时候抛出来。而且，搞的时候必须要检查以下问题：
    - 如果*C*的任意父类是*C*本身，那就要抛一个`ClassCircularityError`。
    - 否则，如果*C*的直接父类实际上是一个接口或`final`类，那就抛一个`IncompatibleClassChangeError`。
    - 否则，如果*C*的直接父类有`PermittedSubclasses`属性（§4.7.31），而且满足以下任意条件，就要抛一个`IncompatibleClassChangeError`：
        - 这个父类跟*C*不在同一个运行时包中（§5.3.6）。
        - *C*不带`ACC_PUBLIC`标记（§4.1），并且这个父类跟*C*不在同一个运行时包中（§5.3）。
        - 这个父类的`PermittedSubclasses`属性的`classes`数组中不存在引用名为*N*的类或接口的记录。
    - 否则，如果*C*是一个类，并且*C*中声明的某个实例方法会覆盖（§5.4.5）它父类中的一个`final`实例方法，那么要抛`IncompatibleClassChangeError`。
4. 如果*C*存在直接父接口，那么从*C*到它的直接父接口的符号引用的解析使用§5.4.3.1中的算法。<br/><br/>类或接口解析失败时抛出的异常都可以在往出搞类的时候抛出来。而且，搞的时候必须要检查以下问题：
    - 如果*C*的任意父接口是*C*本身，那就要抛一个`ClassCircularityError`。
    - 否则，如果*C*的直接父接口实际上并不是一个接口，那就抛一个`IncompatibleClassChangeError`。
    - 否则，对于任意*C*的直接父接口，如果*C*的直接父接口有`PermittedSubclasses`属性（§4.7.31），而且满足以下任意条件，就要抛一个`IncompatibleClassChangeError`：
        - 这个父接口跟*C*不在同一个运行时包中（§5.3.6）。
        - *C*不带`ACC_PUBLIC`标记（§4.1），并且这个父接口跟*C*不在同一个运行时包中。
        - 这个父接口的`PermittedSubclasses`属性的`classes`数组中不存在引用名为*N*的类或接口的记录。

如果以上1-4步骤中没有发生异常，那么类或接口*C*就搞成功了。JVM把*C*的定义加载器标记为*L*，把*L*记录成*C*的一个启动加载器（§5.3.4），并在方法区（§2.5.4）中创建*C*。

&emsp;&emsp;<sub>一旦搞成功了，必须要等到参与*C*加载过程（直接或间接）的所有类加载器都返回了结果*C*，这样*C*的加载和创建才算是完成了。根据用户自定义的类加载器干的那些事儿来看，*C*的加载和创建过程还是有可能会失败的（§5.3.2）。</sub>

如果1-4步骤中抛出了异常，那么类或接口*C*的暗夜行动就以该异常而失败。

### 5.3.6 模块与分层

JVM支持将类和接口组织成模块。类或接口*C*在模块*M*中的身份可以用来控制从其它模块的类和接口对*C*的访问（§5.4.4）。

模块身份要用运行时包（§5.3）来定义。程序要判断出每个模块中的包的名字，以及创建这些包中的类和接口的类加载器；然后拿着这些包和类加载器去调用`ModuleLayer`类的`defineModule`方法。调用该方法可以让JVM创建一个新的*运行时模块*，它关联了类加载器的运行时包。

每个运行时模块都给出了它*导出*的运行时包，这会影响对这些运行时包中的`public`类和接口的访问。每个运行时模块还给出了它*读取*的其它运行时模块，这会影响它内部的代码对这些运行时模块中`public`类型和接口的访问。

我们说*一个类在一个运行时模块中*，当且仅当该类的运行时包关联了（如果该类真正被创建了，那就是将要关联）这个运行时模块。

一个类只会被一个类加载器创建到一个运行时包中，也就是只有一个运行时模块，因为JVM不支持一个运行时包关联（更形象的说应该是“分散在”）多个运行时模块。

一个运行时模块只会隐式的绑定到一个类加载器，这是由`defineModules`的语义决定的。另一方面，一个类加载器可以创建出不同运行时模块中的类，因为JVM不要求一个类加载器的所有运行时包都要关联到同样的运行时模块上。

&emsp;&emsp;<sub>换句话说，类加载器和运行时模块不需要是1:1的。对于一组要加载的模块，如果程序能够判断出每个模块中的包名仅出现在该模块中，那么程序就可以只定义一个类加载器来调用`defineModules`。这个类加载器可以在多个运行时模块中创建类。</sub>

每个由`defineModules`创建的运行时模块都属于一个*层*。一层就代表了一组类加载器，它们共同创建了一组运行时模块中的类。一共有两种层：JVM提供的引导层，以及用户自定义层。引导层在JVM启动的时候以实现特定的方式创建。它把标准运行时模块`java.base`和引导类加载器定义的标准运行时包关联了起来，比如`java.lang`。用户自定义的层由程序来创建，可以创建出多组运行时模块，它们都依赖了`java.base`以及其它的标准运行时模块。

一个运行时模块只会隐式的包含于一个层中，这是由`defineModules`的语义决定的。但是，一个类加载器可能会创建出不同层中运行时模块中的类，因为同一个类加载器可能要多次调用`defineModules`。访问控制是由类的运行时模块来决定的，而不是创建它的类加载器或是类加载器服务的层（们）。

类加载器都定义在一个层中，运行时模块也都是一个层的组成部分，在层创建之后，这些都是不可变的。但是`ModuleLayer`类为程序提供了一定程度的动态控制，可以控制一个用户自定义层中运行时模块之间的关系。

如果一个用户自定义的层包含了多个类加载器，那么创建该层的程序就要负责这些类加载器之间的委派。JVM不会检查层内类加载器之间的委派是否跟层内运行时模块之间的访问一致。而且，如果为了获取其他的运行时模块，一个层的运行时模块被`ModuleLayer`类修改了，那么JVM也不会去检查层中的类加载器是否被某种旁门左道的机制调整过，让委派也形成一致。

&emsp;&emsp;<sub>类加载器和层之间有类似的地方也有不一样的地方。另一方面，一个层跟一个类加载器的相似之处包括它们都可以委派给多个在它们之前创建模块或类的父层或类加载器。如此说来，一个层中定义的模块可能会依赖于不属于该层的模块，它们是在这之前定义在一个或多个父层中的模块。再另一方面，一个层只能用来创建一次新模块，而一个类加载器可以通过多次调用`defineClass`随时创建新的类或接口。</sub>

类加载器可以定义与它所在层任何运行时模块都无关的一个运行时包中的类或接口。如果运行时包不是用`defineModules`定义的就会出现这种情况，或者是一个具有简单二进制名（§4.2.1）的类或接口属于一个未命名运行时包（JLS §7.4.2），也会出现这种情况。不管是哪种场景，这种类或接口都被看作是一个特殊的运行时模块中的成员，隐式绑定到了该类加载器上。这种特殊的运行时模块就叫做该类加载器的*未命名模块*。这种类或接口的运行时包关联了这个类加载器的未命名模块。对于未命名模块有一些特殊的规则，用来最大化它们跟其它运行时包之间的互操作性，具体如下：

- 一个类加载器的未命名模块不同于绑定到该类加载的所有其它的运行时模块。
- 一个类加载器的未命名模块不同于绑定到其它类加载器的所有运行时模块（包括未命名模块）。
- 每个未命名模块都可以读取每一个运行时模块。
- 每个未命名模块都把它所有的运行时包导出给每一个运行时模块。

## 5.4 链接

对一个类或接口进行链接，就是要按需校验和准备这个类或接口，以及它的直接父类、直接父接口、元素类型（如果是数组类型）。链接还要解析类或接口中的符号引用，尽管不用跟类或接口的校验和准备同时进行。

本规范允许具体实现灵活地选择链接（以及由于递归导致的加载）的时机，这是由于保证了以下几点要素：

- 类或接口在链接前完全加载好。
- 类或接口在初始化前完全校验和准备好。
- 链接期间发生的错误会在程序中报出来，啥时候报咧，当程序执行某个操作直接或间接的需要链接报错的类或接口时，错误就报出来了。
- 动态计算常量的符号引用不会进行解析，直到（i）执行了一个引用它的*ldc*、*ldc_w*、*ldc2_w*指令，或（ii）将它作为静态参数的某个引导方法被调用了。<br/><br/>动态计算调用点的符号引用不会进行解析，知道将它作为静态参数的某个引导方法被调用了。

比如，JVM的实现可以选择“懒”链接策略，类或接口中的符号引用（除了上面说的符号引用）只在用到的时候单独解析。或者也可以选择“饥渴的”链接策略，类或接口在校验时一次性把所有符号引用都解析了。这就是说在某些实现中，类或接口初始化之后有可能解析过程还能继续。不管走哪种策略，解析过程中发现的错误必须要在程序中的某一点上，（直接或间接）使用类或接口的符号引用时报出来。

由于链接的时候要分配新的数据结构，所以它也可能因为`OutOfMemoryError`而失败。

### 5.4.1 校验

*校验*（§4.10）可以保证类或接口的二进制表达是格式正确的（§4.9）。校验的时候可能会把其它的类加载（§5.3）进来，但是不会校验或准备它们。

如果类或接口的二进制表达无法满足§4.9列出的静态或结构化约束，那么在程序中导致该类或接口被校验的某处必须要抛出一个`VerifyError`。

如果JVM尝试校验一个类或接口时因为`LinkageError`（或子类）实例错误失败，那么后续对这个类或接口的校验总是会跟最初的尝试一样，以同样的错误失败。

### 5.4.2 准备

*准备*就是要创建类或接口的静态字段并把它们初始化到对应的默认值（§2.3，§2.4）。这个事儿不需要执行任何JVM代码；静态字段的显式初始化器作为初始化（§5.5）的一部分来进行，不在准备阶段。

在类或接口*C*的准备阶段，JVM暗含以下加载约束（§5.3.4）：

1. 假设<code><i>L<sub>i</sub></i></code>是*C*的定义加载器。对于*C*中声明的每一个可以覆盖（§5.4.5）父类或父接口<code><i>&lt;D, L<sub>2</sub>&gt;</i></code>中的实例方法<code><i>m</i></code>，JVM暗含以下加载约束。<br/><br/>假设<code><i>m</i></code>的返回类型为<code><i>T<sub>r</sub></i></code>，且<code><i>m</i></code>的形参类型为<code><i>T<sub>f1</sub>, ..., T<sub>fn</sub></i></code>：<br/><br/>如果<code><i>T<sub>r</sub></i></code>不是数组类型，那么<code><i>T<sub>0</sub></i></code>就是<code><i>T<sub>r</sub></i></code>；否则，<code><i>T<sub>0</sub></i></code>就是<code><i>T<sub>r</sub></i></code>的元素类型。<br/><br/>循环*i*=1到*n*：如果<code><i>T<sub>fi</sub></i></code>不是数组类型，那么<code><i>T<sub>i</sub></i></code>就是<code><i>T<sub>fi</sub></i></code>；否则，<code><i>T<sub>i</sub></i></code>就是<code><i>T<sub>fi</sub></i></code>的元素类型。<br/><br/>然后循环*i*=0到*n*，执行<code><i>T<sub>i</sub></i><sup>L<sub>1</sub></sup> = <i>T<sub>i</sub></i><sup>L<sub>2</sub></sup></code>。
2. 对于*C*的父类<code><i>&lt;I, L<sub>3</sub>&gt;</i></code>中声明的每个实例方法<code><i>m</i></code>，如果*C*中没有声明可以覆盖<code><i>m</i></code>的实例方法，那么就要参考*C*和<code><i>&lt;I, L<sub>3</sub>&gt;</i></code>中的方法<code><i>m</i></code>来进行方法选择。假设<code><i>&lt;D, L<sub>2</sub>&gt;</i></code>就是被选中方法的类或接口。那么JVM暗含以下加载约束。<br/><br/>假设<code><i>m</i></code>的返回类型为<code><i>T<sub>r</sub></i></code>，且<code><i>m</i></code>的形参类型为<code><i>T<sub>f1</sub>, ..., T<sub>fn</sub></i></code>：<br/><br/>如果<code><i>T<sub>r</sub></i></code>不是数组类型，那么<code><i>T<sub>0</sub></i></code>就是<code><i>T<sub>r</sub></i></code>；否则，<code><i>T<sub>0</sub></i></code>就是<code><i>T<sub>r</sub></i></code>的元素类型。<br/><br/>循环*i*=1到*n*：如果<code><i>T<sub>fi</sub></i></code>不是数组类型，那么<code><i>T<sub>i</sub></i></code>就是<code><i>T<sub>fi</sub></i></code>；否则，<code><i>T<sub>i</sub></i></code>就是<code><i>T<sub>fi</sub></i></code>的元素类型。<br/><br/>然后循环*i*=0到*n*，执行<code><i>T<sub>i</sub></i><sup>L<sub>2</sub></sup> = <i>T<sub>i</sub></i><sup>L<sub>3</sub></sup></code>。

准备阶段可能发生在创建之后的任意时间，但是必须要在初始化之前完成。

### 5.4.3 解析

许多JVM指令——*anewarray, checkcast, getfield, getstatic, instanceof, invokedynamic, invokeinterface, invokespecial, invokestatic, invokevirtual, ldc, ldc_w, ldc2_w, multianewarray, new, putfield, putstatic*——依赖运行时常量池中的符号引用。这些指令的执行都需要*解析*符号引用。

解析过程就是要动态的判断出运行时常量池中的一个符号引用的一个或多个具体的值。在开始时，运行时常量池中的符号引用都是未解析的。

对于（i）类或接口，（ii）字段，（iii）方法，（iv）方法类型，（v）方法句柄，（vi）动态计算常量，指向它们的一个未解析的符号引用，解析过程要遵守§5.4.3.1到§5.4.3.5中给出的规则。在前三小节中，出现符号引用的运行时常量池所在的类或接口标为*D*。然后：

- 如果符号引用解析过程中没有报错，那么解析成功。<br/><br/>后面如果再尝试对这个符号引用进行解析那么就直接成功，直接返回跟首次解析一样的结果实体。如果符号引用的是一个动态计算常量，那就不会为后续的尝试执行引导方法。
- 如果符号引用解析过程中出错了，那么它要么是（i）一个`IncompatibleClassChangeError`（或子类）的一个实例；（ii）解析锅调用某个引导方法时产生的一个`Error`（或子类）的一个实例；（iii）由于类加载失败或违反加载器约束而产生的一个`LinkageError`（或子类）的一个实例。这个错误必须在程序中（直接或间接）使用符号引用的某一点上报出来。<br/><br/>后续再对这个符号引用进行解析的话就直接失败，报的错跟首次尝试解析时抛出的一样。如果符号引用的是一个动态计算常量，那就不会为后续的尝试执行引导方法。<br/><br/>&emsp;&emsp;<sub>由于在一开始尝试解析过程中报的错误再后续尝试中重复抛出，所以当一个模块中的一个类尝试通过它运行时常量池中的符号引用访问另一个模块中的一个未导出的`public`类型时总是会得到同样的错误，告诉你那是一个不可访问的类型（§5.4.4），*即便在该类的首次尝试之后的某一时刻会使用JavaSE平台API来动态的导出该`public`类型所在的包*。</sub>

对于动态计算调用点的未解析符号引用的解析过程要符合§5.4.3.6中的规则。然后：

- 如果符号引用解析过程没有报错，那么解析成功*仅限于`class`文件中需要解析的指令*。这个指令必须要有一个*invokedynamic*操作码。<br/><br/>*在该`class`文件中的这条指令*后续对该符号引用的机械系直接成功，直接返回跟首次解析一样的结果实体。不会为后续的尝试执行引导方法。<br/><br/>对于该`class`文件中的所有其它指令的所有操作码，该符号引用仍旧是未解析的，它在运行时常量池中代表的记录跟上面的*invokedynamic*指令的一样。（最后这句没太明白。）
- 